// Copyright (c) 2009 Mercury Federal Systems.
// 
// This file is part of OpenCPI.
// 
// OpenCPI is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// OpenCPI is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public License
// along with OpenCPI.  If not, see <http://www.gnu.org/licenses/>.


#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <CpiTimeEmitC.h>

#undef c_plus_plus
#include "LoopbackWorker.h"

enum PortIds {
        LoopbackWorker_Data_Out_Port=0,
    LoopbackWorker_Data_In_Port=1,
        LastPort
};


static RCCResult initialize(RCCWorker *this_)
{
        LoopbackWorkerStaticMemory *mem = (LoopbackWorkerStaticMemory*)this_->memories[0];
        LoopbackWorkerProperties *props = this_->properties;

        mem->state = LB_New_Input;
        mem->startIndex = 0;
        mem->overlapSize = 0;

        props->startIndex = mem->startIndex;
        props->longProperty = 0;

        return RCC_OK;
}


static RCCResult start(RCCWorker *this_)
{
        return RCC_OK;
}


static RCCResult stop(RCCWorker *this_)
{
        return RCC_OK;
}

static RCCResult release(RCCWorker *this_)
{
        return RCC_OK;
}

static RCCResult test(RCCWorker *this_)
{
        return RCC_OK;
}


static RCCResult afterConfigure(RCCWorker *this_)
{
  /* This only works for simple memory configurations */
    LoopbackWorkerStaticMemory *static_mem = this_->memories[0];
    LoopbackWorkerProperties *props = this_->properties;

    static_mem->longProperty = props->longProperty;
        return RCC_OK;
}


static RCCResult beforeQuery(RCCWorker *this_)
{
  /* This only works for simple memory configurations */
    LoopbackWorkerStaticMemory *static_mem = this_->memories[0];
    LoopbackWorkerProperties *props = this_->properties;

    props->startIndex = static_mem->startIndex;

    return RCC_OK;
}

static RCCResult LoopbackWorker_run(RCCWorker *this_,RCCBoolean timedout,RCCBoolean *newRunCondition)
{
  uint32_t len;

  LoopbackWorkerStaticMemory *mem = this_->memories[0];
  LoopbackWorkerProperties *props = this_->properties;

  char* in_buffer = (char*)this_->ports[LoopbackWorker_Data_In_Port].current.data;
  char* out_buffer = (char*)this_->ports[LoopbackWorker_Data_Out_Port].current.data;

  /*  printf("In LoopbackWorker_run\n"); */

  len = this_->ports[LoopbackWorker_Data_In_Port].input.length;
  this_->ports[LoopbackWorker_Data_Out_Port].output.length = len;

  /*  printf("LB len = %d\n", len ); */


#ifdef DATA_CHECK
  for (n=0; n<len; n++) {
          if ( in_buffer[n] != (char)n%256 ) {
                  printf("LB: Data integrity error !!, expected %d, got %d\n", (char)n%256, in_buffer[n]);
          }
  }
  printf("Data integrity passes in the LB:\n");
#endif

#define LOOPBACK_DATA
#ifdef LOOPBACK_DATA
  memcpy(out_buffer,in_buffer,len);
#endif


#define NZCOPYIO

  /*
#ifdef NZCOPYIO
  this_->container->send( &this_->ports[LoopbackWorker_Data_Out_Port], 
                        &this_->ports[LoopbackWorker_Data_Out_Port].current, 0x54, len );
  this_->container->release( &this_->ports[LoopbackWorker_Data_In_Port].current );
#else
  this_->container->send( &this_->ports[LoopbackWorker_Data_Out_Port], 
                        &this_->ports[LoopbackWorker_Data_In_Port].current, 0x54, len );
#endif
  */


  return RCC_ADVANCE;

}



/*
 * The following code is generated by the tool
 */
#define NUM_PORTS          2
#define NUM_INPUT_PORTS    1
#define NUM_OUTPUT_PORTS   1
#define PROPERTY_SIZE      sizeof( LoopbackWorkerProperties )
static uint32_t memSizes[] = {sizeof(LoopbackWorkerStaticMemory), 1024*10, 0 };
//static int32_t portRunConditions[] = { (1<<LoopbackWorker_Data_In_Port) | (1<<LoopbackWorker_Data_Out_Port) , 0 };

#ifdef NZCOPYIO
static int32_t portRunConditions[] = { ((1<<LoopbackWorker_Data_In_Port) | (1<<LoopbackWorker_Data_Out_Port)), 0 };
#else
static int32_t portRunConditions[] = { (1<<LoopbackWorker_Data_In_Port), 0 };
#endif
static RCCRunCondition workerRunConditions[] = { portRunConditions, 0 , 0 };
static RCCPortInfo portInfo = { 0, 1024*12, 1 };
RCCDispatch LoopbackWorkerDispatchTable = { RCC_VERSION, NUM_INPUT_PORTS, NUM_OUTPUT_PORTS, 
                                            PROPERTY_SIZE, memSizes, 0,
                                            initialize, 
                                            start, 
                                            stop, 
                                            release, 
                                            test, 
                                            afterConfigure, 
                                            beforeQuery, 
                                            LoopbackWorker_run,
                                            workerRunConditions, 
                                            NULL, 
                                            0};








