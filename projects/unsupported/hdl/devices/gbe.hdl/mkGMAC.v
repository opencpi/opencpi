/*
 * This file is protected by Copyright. Please refer to the COPYRIGHT file
 * distributed with this source distribution.
 *
 * This file is part of OpenCPI <http://www.opencpi.org>
 *
 * OpenCPI is free software: you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * OpenCPI is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

//
// Generated by Bluespec Compiler, version 2013.01.beta5 (build 30325, 2013-01-23)
//
// On Fri Jun 21 16:56:48 EDT 2013
//
//
// Ports:
// Name                         I/O  size props
// gmii_tx_txd                    O     8
// gmii_tx_tx_en                  O     1
// gmii_tx_tx_er                  O     1
// gmii_led                       O     1 reg
// rx_get                         O    10
// RDY_rx_get                     O     1
// RDY_tx_put                     O     1
// RDY_rxOperate                  O     1 const
// RDY_txOperate                  O     1 const
// rxOverFlow                     O     1
// RDY_rxOverFlow                 O     1 const
// txUnderFlow                    O     1
// RDY_txUnderFlow                O     1 const
// phyInterrupt                   O     1
// RDY_phyInterrupt               O     1 const
// CLK_gmii_tx_tx_clk             O     1 clock
// CLK_GATE_gmii_tx_tx_clk        O     1 const
// CLK_rxclkBnd                   O     1 clock
// CLK_GATE_rxclkBnd              O     1 const
// CLK_rxClk                      I     1 clock
// CLK_txClk                      I     1 clock
// CLK                            I     1 clock
// RST_N                          I     1 reset
// gmii_rx_rxd_i                  I     8 reg
// gmii_rx_rx_dv_i                I     1 reg
// gmii_rx_rx_er_i                I     1 reg
// gmii_col_i                     I     1
// gmii_crs_i                     I     1
// gmii_intr_i                    I     1
// tx_put                         I    10
// EN_tx_put                      I     1
// EN_rxOperate                   I     1
// EN_txOperate                   I     1 reg
// EN_rx_get                      I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkGMAC(CLK_rxClk,
	      CLK_txClk,
	      CLK,
	      RST_N,

	      gmii_rx_rxd_i,

	      gmii_rx_rx_dv_i,

	      gmii_rx_rx_er_i,

	      gmii_tx_txd,

	      gmii_tx_tx_en,

	      gmii_tx_tx_er,

	      gmii_col_i,

	      gmii_crs_i,

	      gmii_intr_i,

	      gmii_led,

	      EN_rx_get,
	      rx_get,
	      RDY_rx_get,

	      tx_put,
	      EN_tx_put,
	      RDY_tx_put,

	      EN_rxOperate,
	      RDY_rxOperate,

	      EN_txOperate,
	      RDY_txOperate,

	      rxOverFlow,
	      RDY_rxOverFlow,

	      txUnderFlow,
	      RDY_txUnderFlow,

	      phyInterrupt,
	      RDY_phyInterrupt,

	      CLK_gmii_tx_tx_clk,
	      CLK_GATE_gmii_tx_tx_clk,

	      CLK_rxclkBnd,
	      CLK_GATE_rxclkBnd);
  input  CLK_rxClk;
  input  CLK_txClk;
  input  CLK;
  input  RST_N;

  // action method gmii_rx_rxd
  input  [7 : 0] gmii_rx_rxd_i;

  // action method gmii_rx_rx_dv
  input  gmii_rx_rx_dv_i;

  // action method gmii_rx_rx_er
  input  gmii_rx_rx_er_i;

  // value method gmii_tx_txd
  output [7 : 0] gmii_tx_txd;

  // value method gmii_tx_tx_en
  output gmii_tx_tx_en;

  // value method gmii_tx_tx_er
  output gmii_tx_tx_er;

  // action method gmii_col
  input  gmii_col_i;

  // action method gmii_crs
  input  gmii_crs_i;

  // action method gmii_intr
  input  gmii_intr_i;

  // value method gmii_led
  output gmii_led;

  // actionvalue method rx_get
  input  EN_rx_get;
  output [9 : 0] rx_get;
  output RDY_rx_get;

  // action method tx_put
  input  [9 : 0] tx_put;
  input  EN_tx_put;
  output RDY_tx_put;

  // action method rxOperate
  input  EN_rxOperate;
  output RDY_rxOperate;

  // action method txOperate
  input  EN_txOperate;
  output RDY_txOperate;

  // value method rxOverFlow
  output rxOverFlow;
  output RDY_rxOverFlow;

  // value method txUnderFlow
  output txUnderFlow;
  output RDY_txUnderFlow;

  // value method phyInterrupt
  output phyInterrupt;
  output RDY_phyInterrupt;

  // oscillator and gates for output clock CLK_gmii_tx_tx_clk
  output CLK_gmii_tx_tx_clk;
  output CLK_GATE_gmii_tx_tx_clk;

  // oscillator and gates for output clock CLK_rxclkBnd
  output CLK_rxclkBnd;
  output CLK_GATE_rxclkBnd;

  // signals for module outputs
  wire [9 : 0] rx_get;
  wire [7 : 0] gmii_tx_txd;
  wire CLK_GATE_gmii_tx_tx_clk,
       CLK_GATE_rxclkBnd,
       CLK_gmii_tx_tx_clk,
       CLK_rxclkBnd,
       RDY_phyInterrupt,
       RDY_rxOperate,
       RDY_rxOverFlow,
       RDY_rx_get,
       RDY_txOperate,
       RDY_txUnderFlow,
       RDY_tx_put,
       gmii_led,
       gmii_tx_tx_en,
       gmii_tx_tx_er,
       phyInterrupt,
       rxOverFlow,
       txUnderFlow;

  // inlined wires
  reg [7 : 0] txRS_txData_1$wget;
  wire rxRS_crcDbgCnt_decAction$whas,
       rxRS_crcDbgCnt_incAction$whas,
       rxRS_preambleCnt_decAction$whas,
       rxRS_preambleCnt_incAction$whas,
       rxRS_rxOperateD_1$wget,
       rxRS_rxOperateD_1$whas,
       txRS_crcDbgCnt_decAction$whas,
       txRS_crcDbgCnt_incAction$whas,
       txRS_ifgCnt_decAction$whas,
       txRS_ifgCnt_incAction$whas,
       txRS_lenCnt_decAction$whas,
       txRS_lenCnt_incAction$whas,
       txRS_preambleCnt_decAction$whas,
       txRS_preambleCnt_incAction$whas,
       txRS_txDV_1$wget,
       txRS_txDV_1$whas,
       txRS_txData_1$whas,
       txRS_txER_1$wget,
       txRS_txER_1$whas,
       txRS_txOperateD_1$wget,
       txRS_txOperateD_1$whas,
       txRS_underflow_1$wget,
       txRS_underflow_1$whas;

  // register gmacLED
  reg gmacLED;
  wire gmacLED$D_IN, gmacLED$EN;

  // register rxRS_crcDbgCnt_value
  reg [11 : 0] rxRS_crcDbgCnt_value;
  wire [11 : 0] rxRS_crcDbgCnt_value$D_IN;
  wire rxRS_crcDbgCnt_value$EN;

  // register rxRS_crcEnd
  reg rxRS_crcEnd;
  wire rxRS_crcEnd$D_IN, rxRS_crcEnd$EN;

  // register rxRS_fullD
  reg rxRS_fullD;
  wire rxRS_fullD$D_IN, rxRS_fullD$EN;

  // register rxRS_isSOF
  reg rxRS_isSOF;
  wire rxRS_isSOF$D_IN, rxRS_isSOF$EN;

  // register rxRS_preambleCnt_value
  reg [3 : 0] rxRS_preambleCnt_value;
  wire [3 : 0] rxRS_preambleCnt_value$D_IN;
  wire rxRS_preambleCnt_value$EN;

  // register rxRS_rxAPipe
  reg [5 : 0] rxRS_rxAPipe;
  wire [5 : 0] rxRS_rxAPipe$D_IN;
  wire rxRS_rxAPipe$EN;

  // register rxRS_rxActive
  reg rxRS_rxActive;
  wire rxRS_rxActive$D_IN, rxRS_rxActive$EN;

  // register rxRS_rxDV
  reg rxRS_rxDV;
  wire rxRS_rxDV$D_IN, rxRS_rxDV$EN;

  // register rxRS_rxDVD
  reg rxRS_rxDVD;
  wire rxRS_rxDVD$D_IN, rxRS_rxDVD$EN;

  // register rxRS_rxDVD2
  reg rxRS_rxDVD2;
  wire rxRS_rxDVD2$D_IN, rxRS_rxDVD2$EN;

  // register rxRS_rxData
  reg [7 : 0] rxRS_rxData;
  wire [7 : 0] rxRS_rxData$D_IN;
  wire rxRS_rxData$EN;

  // register rxRS_rxER
  reg rxRS_rxER;
  wire rxRS_rxER$D_IN, rxRS_rxER$EN;

  // register rxRS_rxOperateD
  reg rxRS_rxOperateD;
  wire rxRS_rxOperateD$D_IN, rxRS_rxOperateD$EN;

  // register rxRS_rxPipe
  reg [47 : 0] rxRS_rxPipe;
  wire [47 : 0] rxRS_rxPipe$D_IN;
  wire rxRS_rxPipe$EN;

  // register txRS_crcDbgCnt_value
  reg [11 : 0] txRS_crcDbgCnt_value;
  wire [11 : 0] txRS_crcDbgCnt_value$D_IN;
  wire txRS_crcDbgCnt_value$EN;

  // register txRS_doPad
  reg txRS_doPad;
  wire txRS_doPad$D_IN, txRS_doPad$EN;

  // register txRS_emitFCS
  reg [2 : 0] txRS_emitFCS;
  wire [2 : 0] txRS_emitFCS$D_IN;
  wire txRS_emitFCS$EN;

  // register txRS_ifgCnt_value
  reg [4 : 0] txRS_ifgCnt_value;
  wire [4 : 0] txRS_ifgCnt_value$D_IN;
  wire txRS_ifgCnt_value$EN;

  // register txRS_isSOF
  reg txRS_isSOF;
  wire txRS_isSOF$D_IN, txRS_isSOF$EN;

  // register txRS_lenCnt_value
  reg [11 : 0] txRS_lenCnt_value;
  wire [11 : 0] txRS_lenCnt_value$D_IN;
  wire txRS_lenCnt_value$EN;

  // register txRS_preambleCnt_value
  reg [4 : 0] txRS_preambleCnt_value;
  wire [4 : 0] txRS_preambleCnt_value$D_IN;
  wire txRS_preambleCnt_value$EN;

  // register txRS_txActive
  reg txRS_txActive;
  wire txRS_txActive$D_IN, txRS_txActive$EN;

  // register txRS_txDV
  reg txRS_txDV;
  wire txRS_txDV$D_IN, txRS_txDV$EN;

  // register txRS_txData
  reg [7 : 0] txRS_txData;
  wire [7 : 0] txRS_txData$D_IN;
  wire txRS_txData$EN;

  // register txRS_txER
  reg txRS_txER;
  wire txRS_txER$D_IN, txRS_txER$EN;

  // register txRS_txOperateD
  reg txRS_txOperateD;
  wire txRS_txOperateD$D_IN, txRS_txOperateD$EN;

  // register txRS_underflow
  reg txRS_underflow;
  wire txRS_underflow$D_IN, txRS_underflow$EN;

  // register txRS_unfD
  reg txRS_unfD;
  wire txRS_unfD$D_IN, txRS_unfD$EN;

  // ports of submodule col_cc
  wire col_cc$sD_IN, col_cc$sEN;

  // ports of submodule crs_cc
  wire crs_cc$sD_IN, crs_cc$sEN;

  // ports of submodule gmii_rx_clk
  wire gmii_rx_clk$O;

  // ports of submodule gmii_rxc_dly
  wire gmii_rxc_dly$DATAOUT;

  // ports of submodule intr_cc
  wire intr_cc$dD_OUT, intr_cc$sD_IN, intr_cc$sEN;

  // ports of submodule phyReset
  wire phyReset$OUT_RST;

  // ports of submodule rxClk_BUFR
  wire rxClk_BUFR$O;

  // ports of submodule rxRS_crc
  wire [31 : 0] rxRS_crc$complete;
  wire [7 : 0] rxRS_crc$add_data;
  wire rxRS_crc$EN_add, rxRS_crc$EN_clear, rxRS_crc$EN_complete;

  // ports of submodule rxRS_ovfBit
  wire rxRS_ovfBit$dD_OUT, rxRS_ovfBit$sD_IN, rxRS_ovfBit$sEN;

  // ports of submodule rxRS_rxF
  wire [9 : 0] rxRS_rxF$dD_OUT, rxRS_rxF$sD_IN;
  wire rxRS_rxF$dDEQ, rxRS_rxF$dEMPTY_N, rxRS_rxF$sENQ, rxRS_rxF$sFULL_N;

  // ports of submodule rxRS_rxOperateS
  wire rxRS_rxOperateS$dD_OUT, rxRS_rxOperateS$sD_IN, rxRS_rxOperateS$sEN;

  // ports of submodule rxRS_rxRst
  wire rxRS_rxRst$OUT_RST;

  // ports of submodule txRS_crc
  wire [31 : 0] txRS_crc$result;
  wire [7 : 0] txRS_crc$add_data;
  wire txRS_crc$EN_add, txRS_crc$EN_clear, txRS_crc$EN_complete;

  // ports of submodule txRS_iobTxClk
  wire txRS_iobTxClk$Q;

  // ports of submodule txRS_iobTxClk_reset
  wire txRS_iobTxClk_reset$RESET_OUT;

  // ports of submodule txRS_iobTxData
  wire txRS_iobTxData$CE,
       txRS_iobTxData$D1,
       txRS_iobTxData$D2,
       txRS_iobTxData$Q,
       txRS_iobTxData$S;

  // ports of submodule txRS_iobTxData_1
  wire txRS_iobTxData_1$CE,
       txRS_iobTxData_1$D1,
       txRS_iobTxData_1$D2,
       txRS_iobTxData_1$Q,
       txRS_iobTxData_1$S;

  // ports of submodule txRS_iobTxData_2
  wire txRS_iobTxData_2$CE,
       txRS_iobTxData_2$D1,
       txRS_iobTxData_2$D2,
       txRS_iobTxData_2$Q,
       txRS_iobTxData_2$S;

  // ports of submodule txRS_iobTxData_3
  wire txRS_iobTxData_3$CE,
       txRS_iobTxData_3$D1,
       txRS_iobTxData_3$D2,
       txRS_iobTxData_3$Q,
       txRS_iobTxData_3$S;

  // ports of submodule txRS_iobTxData_4
  wire txRS_iobTxData_4$CE,
       txRS_iobTxData_4$D1,
       txRS_iobTxData_4$D2,
       txRS_iobTxData_4$Q,
       txRS_iobTxData_4$S;

  // ports of submodule txRS_iobTxData_5
  wire txRS_iobTxData_5$CE,
       txRS_iobTxData_5$D1,
       txRS_iobTxData_5$D2,
       txRS_iobTxData_5$Q,
       txRS_iobTxData_5$S;

  // ports of submodule txRS_iobTxData_6
  wire txRS_iobTxData_6$CE,
       txRS_iobTxData_6$D1,
       txRS_iobTxData_6$D2,
       txRS_iobTxData_6$Q,
       txRS_iobTxData_6$S;

  // ports of submodule txRS_iobTxData_7
  wire txRS_iobTxData_7$CE,
       txRS_iobTxData_7$D1,
       txRS_iobTxData_7$D2,
       txRS_iobTxData_7$Q,
       txRS_iobTxData_7$S;

  // ports of submodule txRS_iobTxData_reset
  wire txRS_iobTxData_reset$RESET_OUT;

  // ports of submodule txRS_iobTxEna
  wire txRS_iobTxEna$CE,
       txRS_iobTxEna$D1,
       txRS_iobTxEna$D2,
       txRS_iobTxEna$Q,
       txRS_iobTxEna$S;

  // ports of submodule txRS_iobTxEna_reset
  wire txRS_iobTxEna_reset$RESET_OUT;

  // ports of submodule txRS_iobTxErr
  wire txRS_iobTxErr$CE,
       txRS_iobTxErr$D1,
       txRS_iobTxErr$D2,
       txRS_iobTxErr$Q,
       txRS_iobTxErr$S;

  // ports of submodule txRS_iobTxErr_reset
  wire txRS_iobTxErr_reset$RESET_OUT;

  // ports of submodule txRS_txF
  wire [9 : 0] txRS_txF$dD_OUT, txRS_txF$sD_IN;
  wire txRS_txF$dDEQ, txRS_txF$dEMPTY_N, txRS_txF$sENQ, txRS_txF$sFULL_N;

  // ports of submodule txRS_txOperateS
  wire txRS_txOperateS$dD_OUT, txRS_txOperateS$sD_IN, txRS_txOperateS$sEN;

  // ports of submodule txRS_txRst
  wire txRS_txRst$OUT_RST;

  // ports of submodule txRS_unfBit
  wire txRS_unfBit$dD_OUT, txRS_unfBit$sD_IN, txRS_unfBit$sEN;

  // rule scheduling signals
  wire CAN_FIRE_RL_txRS_egress_Body,
       CAN_FIRE_RL_txRS_egress_EOF,
       CAN_FIRE_RL_txRS_egress_SOF,
       WILL_FIRE_RL_rxRS_crcDbgCnt_ruleInc,
       WILL_FIRE_RL_rxRS_egress_data,
       WILL_FIRE_RL_rxRS_end_frame,
       WILL_FIRE_RL_rxRS_ingress_advance,
       WILL_FIRE_RL_rxRS_ingress_noadvance,
       WILL_FIRE_RL_txRS_egress_Body,
       WILL_FIRE_RL_txRS_egress_EOF,
       WILL_FIRE_RL_txRS_egress_FCS,
       WILL_FIRE_RL_txRS_egress_SOF;

  // inputs to muxes for submodule ports
  reg [7 : 0] MUX_txRS_txData_1$wset_1__VAL_1;
  wire [11 : 0] MUX_rxRS_crcDbgCnt_value$write_1__VAL_1,
		MUX_txRS_crcDbgCnt_value$write_1__VAL_2,
		MUX_txRS_lenCnt_value$write_1__VAL_2;
  wire [9 : 0] MUX_rxRS_rxF$enq_1__VAL_1, MUX_rxRS_rxF$enq_1__VAL_2;
  wire [7 : 0] MUX_txRS_crc$add_1__VAL_2, MUX_txRS_txData_1$wset_1__VAL_4;
  wire [5 : 0] MUX_rxRS_rxAPipe$write_1__VAL_2;
  wire [4 : 0] MUX_txRS_ifgCnt_value$write_1__VAL_2,
	       MUX_txRS_preambleCnt_value$write_1__VAL_3;
  wire [3 : 0] MUX_rxRS_preambleCnt_value$write_1__VAL_3;
  wire MUX_rxRS_rxF$enq_1__SEL_1,
       MUX_txRS_crc$add_1__SEL_1,
       MUX_txRS_crcDbgCnt_value$write_1__SEL_1,
       MUX_txRS_emitFCS$write_1__SEL_1,
       MUX_txRS_ifgCnt_value$write_1__SEL_1;

  // remaining internal signals
  reg [63 : 0] v__h12643, v__h6699;
  reg [1 : 0] CASE_rxRS_rxFdD_OUT_BITS_9_TO_8_0_rxRS_rxFdD_ETC__q1,
	      CASE_tx_put_BITS_9_TO_8_0_tx_put_BITS_9_TO_8_1_ETC__q2;
  wire [2 : 0] x__h13660;
  wire txRS_lenCnt_value_45_ULT_59___d209,
       txRS_preambleCnt_value_19_ULT_7___d183;

  // oscillator and gates for output clock CLK_gmii_tx_tx_clk
  assign CLK_gmii_tx_tx_clk = txRS_iobTxClk$Q ;
  assign CLK_GATE_gmii_tx_tx_clk = 1'b1 ;

  // oscillator and gates for output clock CLK_rxclkBnd
  assign CLK_rxclkBnd = rxClk_BUFR$O ;
  assign CLK_GATE_rxclkBnd = 1'b1 ;

  // value method gmii_tx_txd
  assign gmii_tx_txd =
	     { txRS_iobTxData_7$Q,
	       txRS_iobTxData_6$Q,
	       txRS_iobTxData_5$Q,
	       txRS_iobTxData_4$Q,
	       txRS_iobTxData_3$Q,
	       txRS_iobTxData_2$Q,
	       txRS_iobTxData_1$Q,
	       txRS_iobTxData$Q } ;

  // value method gmii_tx_tx_en
  assign gmii_tx_tx_en = txRS_iobTxEna$Q ;

  // value method gmii_tx_tx_er
  assign gmii_tx_tx_er = txRS_iobTxErr$Q ;

  // value method gmii_led
  assign gmii_led = gmacLED ;

  // actionvalue method rx_get
  assign rx_get =
	     { CASE_rxRS_rxFdD_OUT_BITS_9_TO_8_0_rxRS_rxFdD_ETC__q1,
	       rxRS_rxF$dD_OUT[7:0] } ;
  assign RDY_rx_get = rxRS_rxF$dEMPTY_N ;

  // action method tx_put
  assign RDY_tx_put = txRS_txF$sFULL_N ;

  // action method rxOperate
  assign RDY_rxOperate = 1'd1 ;

  // action method txOperate
  assign RDY_txOperate = 1'd1 ;

  // value method rxOverFlow
  assign rxOverFlow = rxRS_ovfBit$dD_OUT ;
  assign RDY_rxOverFlow = 1'd1 ;

  // value method txUnderFlow
  assign txUnderFlow = txRS_unfBit$dD_OUT ;
  assign RDY_txUnderFlow = 1'd1 ;

  // value method phyInterrupt
  assign phyInterrupt = !intr_cc$dD_OUT ;
  assign RDY_phyInterrupt = 1'd1 ;

  // submodule col_cc
  SyncBit #(.init(1'd0)) col_cc(.sCLK(CLK),
				.dCLK(CLK),
				.sRST(phyReset$OUT_RST),
				.sD_IN(col_cc$sD_IN),
				.sEN(col_cc$sEN),
				.dD_OUT());

  // submodule crs_cc
  SyncBit #(.init(1'd0)) crs_cc(.sCLK(CLK),
				.dCLK(CLK),
				.sRST(phyReset$OUT_RST),
				.sD_IN(crs_cc$sD_IN),
				.sEN(crs_cc$sEN),
				.dD_OUT());

  // submodule gmii_rx_clk
  BUFIO gmii_rx_clk(.I(gmii_rxc_dly$DATAOUT), .O(gmii_rx_clk$O));

  // submodule gmii_rxc_dly
  IODELAY #(.IDELAY_TYPE("FIXED"),
	    .IDELAY_VALUE(32'd0),
	    .DELAY_SRC("I"),
	    .SIGNAL_PATTERN("CLOCK"),
	    .HIGH_PERFORMANCE_MODE("TRUE")) gmii_rxc_dly(.IDATAIN(CLK_rxClk),
							 .ODATAIN(32'd0),
							 .DATAIN(32'd0),
							 .C(32'd0),
							 .T(32'd0),
							 .CE(32'd0),
							 .INC(32'd0),
							 .RST(32'd0),
							 .DATAOUT(gmii_rxc_dly$DATAOUT));

  // submodule intr_cc
  SyncBit #(.init(1'd0)) intr_cc(.sCLK(CLK),
				 .dCLK(CLK),
				 .sRST(phyReset$OUT_RST),
				 .sD_IN(intr_cc$sD_IN),
				 .sEN(intr_cc$sEN),
				 .dD_OUT(intr_cc$dD_OUT));

  // submodule phyReset
  SyncResetA #(.RSTDELAY(32'd7)) phyReset(.CLK(CLK),
					  .IN_RST(RST_N),
					  .OUT_RST(phyReset$OUT_RST));

  // submodule rxClk_BUFR
  BUFR #(.BUFR_DIVIDE("BYPASS")) rxClk_BUFR(.I(gmii_rxc_dly$DATAOUT),
					    .CE(1'd1),
					    .CLR(1'd0),
					    .O(rxClk_BUFR$O));

  // submodule rxRS_crc
  mkCRC32 rxRS_crc(.CLK(rxClk_BUFR$O),
		   .RST_N(rxRS_rxRst$OUT_RST),
		   .add_data(rxRS_crc$add_data),
		   .EN_add(rxRS_crc$EN_add),
		   .EN_clear(rxRS_crc$EN_clear),
		   .EN_complete(rxRS_crc$EN_complete),
		   .RDY_add(),
		   .RDY_clear(),
		   .result(),
		   .RDY_result(),
		   .complete(rxRS_crc$complete),
		   .RDY_complete());

  // submodule rxRS_ovfBit
  SyncBit #(.init(1'd0)) rxRS_ovfBit(.sCLK(rxClk_BUFR$O),
				     .dCLK(CLK),
				     .sRST(rxRS_rxRst$OUT_RST),
				     .sD_IN(rxRS_ovfBit$sD_IN),
				     .sEN(rxRS_ovfBit$sEN),
				     .dD_OUT(rxRS_ovfBit$dD_OUT));

  // submodule rxRS_rxF
  SyncFIFO #(.dataWidth(32'd10),
	     .depth(32'd8),
	     .indxWidth(32'd3)) rxRS_rxF(.sCLK(rxClk_BUFR$O),
					 .dCLK(CLK),
					 .sRST(rxRS_rxRst$OUT_RST),
					 .sD_IN(rxRS_rxF$sD_IN),
					 .sENQ(rxRS_rxF$sENQ),
					 .dDEQ(rxRS_rxF$dDEQ),
					 .dD_OUT(rxRS_rxF$dD_OUT),
					 .sFULL_N(rxRS_rxF$sFULL_N),
					 .dEMPTY_N(rxRS_rxF$dEMPTY_N));

  // submodule rxRS_rxOperateS
  SyncBit #(.init(1'd0)) rxRS_rxOperateS(.sCLK(CLK),
					 .dCLK(rxClk_BUFR$O),
					 .sRST(RST_N),
					 .sD_IN(rxRS_rxOperateS$sD_IN),
					 .sEN(rxRS_rxOperateS$sEN),
					 .dD_OUT(rxRS_rxOperateS$dD_OUT));

  // submodule rxRS_rxRst
  SyncResetA #(.RSTDELAY(32'd1)) rxRS_rxRst(.CLK(rxClk_BUFR$O),
					    .IN_RST(RST_N),
					    .OUT_RST(rxRS_rxRst$OUT_RST));

  // submodule txRS_crc
  mkCRC32 txRS_crc(.CLK(CLK_txClk),
		   .RST_N(txRS_txRst$OUT_RST),
		   .add_data(txRS_crc$add_data),
		   .EN_add(txRS_crc$EN_add),
		   .EN_clear(txRS_crc$EN_clear),
		   .EN_complete(txRS_crc$EN_complete),
		   .RDY_add(),
		   .RDY_clear(),
		   .result(txRS_crc$result),
		   .RDY_result(),
		   .complete(),
		   .RDY_complete());

  // submodule txRS_iobTxClk
  // iobTxClk output is 180 degress out-of-phase for 4 nS SU + 4 nS Hold
  ODDR #(.DDR_CLK_EDGE("SAME_EDGE"),
	 .INIT(1'd0),
	 .SRTYPE("SYNC")) txRS_iobTxClk(.C(CLK_txClk),
					.R(txRS_iobTxClk_reset$RESET_OUT),
					.D1(1'd0),
					.D2(1'd1),
					.CE(1'd1),
					.S(1'd0),
					.Q(txRS_iobTxClk$Q));

  // submodule txRS_iobTxClk_reset
  ResetInverter txRS_iobTxClk_reset(.RESET_IN(txRS_txRst$OUT_RST),
				    .RESET_OUT(txRS_iobTxClk_reset$RESET_OUT));

  // submodule txRS_iobTxData
  ODDR #(.DDR_CLK_EDGE("SAME_EDGE"),
	 .INIT(1'd0),
	 .SRTYPE("SYNC")) txRS_iobTxData(.C(CLK_txClk),
					 .R(txRS_iobTxData_reset$RESET_OUT),
					 .CE(txRS_iobTxData$CE),
					 .D1(txRS_iobTxData$D1),
					 .D2(txRS_iobTxData$D2),
					 .S(txRS_iobTxData$S),
					 .Q(txRS_iobTxData$Q));

  // submodule txRS_iobTxData_1
  ODDR #(.DDR_CLK_EDGE("SAME_EDGE"),
	 .INIT(1'd0),
	 .SRTYPE("SYNC")) txRS_iobTxData_1(.C(CLK_txClk),
					   .R(txRS_iobTxData_reset$RESET_OUT),
					   .CE(txRS_iobTxData_1$CE),
					   .D1(txRS_iobTxData_1$D1),
					   .D2(txRS_iobTxData_1$D2),
					   .S(txRS_iobTxData_1$S),
					   .Q(txRS_iobTxData_1$Q));

  // submodule txRS_iobTxData_2
  ODDR #(.DDR_CLK_EDGE("SAME_EDGE"),
	 .INIT(1'd0),
	 .SRTYPE("SYNC")) txRS_iobTxData_2(.C(CLK_txClk),
					   .R(txRS_iobTxData_reset$RESET_OUT),
					   .CE(txRS_iobTxData_2$CE),
					   .D1(txRS_iobTxData_2$D1),
					   .D2(txRS_iobTxData_2$D2),
					   .S(txRS_iobTxData_2$S),
					   .Q(txRS_iobTxData_2$Q));

  // submodule txRS_iobTxData_3
  ODDR #(.DDR_CLK_EDGE("SAME_EDGE"),
	 .INIT(1'd0),
	 .SRTYPE("SYNC")) txRS_iobTxData_3(.C(CLK_txClk),
					   .R(txRS_iobTxData_reset$RESET_OUT),
					   .CE(txRS_iobTxData_3$CE),
					   .D1(txRS_iobTxData_3$D1),
					   .D2(txRS_iobTxData_3$D2),
					   .S(txRS_iobTxData_3$S),
					   .Q(txRS_iobTxData_3$Q));

  // submodule txRS_iobTxData_4
  ODDR #(.DDR_CLK_EDGE("SAME_EDGE"),
	 .INIT(1'd0),
	 .SRTYPE("SYNC")) txRS_iobTxData_4(.C(CLK_txClk),
					   .R(txRS_iobTxData_reset$RESET_OUT),
					   .CE(txRS_iobTxData_4$CE),
					   .D1(txRS_iobTxData_4$D1),
					   .D2(txRS_iobTxData_4$D2),
					   .S(txRS_iobTxData_4$S),
					   .Q(txRS_iobTxData_4$Q));

  // submodule txRS_iobTxData_5
  ODDR #(.DDR_CLK_EDGE("SAME_EDGE"),
	 .INIT(1'd0),
	 .SRTYPE("SYNC")) txRS_iobTxData_5(.C(CLK_txClk),
					   .R(txRS_iobTxData_reset$RESET_OUT),
					   .CE(txRS_iobTxData_5$CE),
					   .D1(txRS_iobTxData_5$D1),
					   .D2(txRS_iobTxData_5$D2),
					   .S(txRS_iobTxData_5$S),
					   .Q(txRS_iobTxData_5$Q));

  // submodule txRS_iobTxData_6
  ODDR #(.DDR_CLK_EDGE("SAME_EDGE"),
	 .INIT(1'd0),
	 .SRTYPE("SYNC")) txRS_iobTxData_6(.C(CLK_txClk),
					   .R(txRS_iobTxData_reset$RESET_OUT),
					   .CE(txRS_iobTxData_6$CE),
					   .D1(txRS_iobTxData_6$D1),
					   .D2(txRS_iobTxData_6$D2),
					   .S(txRS_iobTxData_6$S),
					   .Q(txRS_iobTxData_6$Q));

  // submodule txRS_iobTxData_7
  ODDR #(.DDR_CLK_EDGE("SAME_EDGE"),
	 .INIT(1'd0),
	 .SRTYPE("SYNC")) txRS_iobTxData_7(.C(CLK_txClk),
					   .R(txRS_iobTxData_reset$RESET_OUT),
					   .CE(txRS_iobTxData_7$CE),
					   .D1(txRS_iobTxData_7$D1),
					   .D2(txRS_iobTxData_7$D2),
					   .S(txRS_iobTxData_7$S),
					   .Q(txRS_iobTxData_7$Q));

  // submodule txRS_iobTxData_reset
  ResetInverter txRS_iobTxData_reset(.RESET_IN(txRS_txRst$OUT_RST),
				     .RESET_OUT(txRS_iobTxData_reset$RESET_OUT));

  // submodule txRS_iobTxEna
  ODDR #(.DDR_CLK_EDGE("SAME_EDGE"),
	 .INIT(1'd0),
	 .SRTYPE("SYNC")) txRS_iobTxEna(.C(CLK_txClk),
					.R(txRS_iobTxEna_reset$RESET_OUT),
					.CE(txRS_iobTxEna$CE),
					.D1(txRS_iobTxEna$D1),
					.D2(txRS_iobTxEna$D2),
					.S(txRS_iobTxEna$S),
					.Q(txRS_iobTxEna$Q));

  // submodule txRS_iobTxEna_reset
  ResetInverter txRS_iobTxEna_reset(.RESET_IN(txRS_txRst$OUT_RST),
				    .RESET_OUT(txRS_iobTxEna_reset$RESET_OUT));

  // submodule txRS_iobTxErr
  ODDR #(.DDR_CLK_EDGE("SAME_EDGE"),
	 .INIT(1'd0),
	 .SRTYPE("SYNC")) txRS_iobTxErr(.C(CLK_txClk),
					.R(txRS_iobTxErr_reset$RESET_OUT),
					.CE(txRS_iobTxErr$CE),
					.D1(txRS_iobTxErr$D1),
					.D2(txRS_iobTxErr$D2),
					.S(txRS_iobTxErr$S),
					.Q(txRS_iobTxErr$Q));

  // submodule txRS_iobTxErr_reset
  ResetInverter txRS_iobTxErr_reset(.RESET_IN(txRS_txRst$OUT_RST),
				    .RESET_OUT(txRS_iobTxErr_reset$RESET_OUT));

  // submodule txRS_txF
  SyncFIFO #(.dataWidth(32'd10),
	     .depth(32'd16),
	     .indxWidth(32'd4)) txRS_txF(.sCLK(CLK),
					 .dCLK(CLK_txClk),
					 .sRST(RST_N),
					 .sD_IN(txRS_txF$sD_IN),
					 .sENQ(txRS_txF$sENQ),
					 .dDEQ(txRS_txF$dDEQ),
					 .dD_OUT(txRS_txF$dD_OUT),
					 .sFULL_N(txRS_txF$sFULL_N),
					 .dEMPTY_N(txRS_txF$dEMPTY_N));

  // submodule txRS_txOperateS
  SyncBit #(.init(1'd0)) txRS_txOperateS(.sCLK(CLK),
					 .dCLK(CLK_txClk),
					 .sRST(RST_N),
					 .sD_IN(txRS_txOperateS$sD_IN),
					 .sEN(txRS_txOperateS$sEN),
					 .dD_OUT(txRS_txOperateS$dD_OUT));

  // submodule txRS_txRst
  SyncResetA #(.RSTDELAY(32'd1)) txRS_txRst(.CLK(CLK_txClk),
					    .IN_RST(RST_N),
					    .OUT_RST(txRS_txRst$OUT_RST));

  // submodule txRS_unfBit
  SyncBit #(.init(1'd0)) txRS_unfBit(.sCLK(CLK_txClk),
				     .dCLK(CLK),
				     .sRST(txRS_txRst$OUT_RST),
				     .sD_IN(txRS_unfBit$sD_IN),
				     .sEN(txRS_unfBit$sEN),
				     .dD_OUT(txRS_unfBit$dD_OUT));

  // rule RL_rxRS_ingress_noadvance
  assign WILL_FIRE_RL_rxRS_ingress_noadvance =
	     (!rxRS_rxActive || rxRS_rxF$sFULL_N) && rxRS_rxOperateS$dD_OUT &&
	     !rxRS_rxDVD &&
	     rxRS_rxAPipe[0] &&
	     rxRS_rxAPipe[1] &&
	     rxRS_rxAPipe[2] &&
	     rxRS_rxAPipe[3] &&
	     rxRS_rxAPipe[4] &&
	     rxRS_rxAPipe[5] &&
	     !rxRS_crcEnd ;

  // rule RL_rxRS_egress_data
  assign WILL_FIRE_RL_rxRS_egress_data =
	     rxRS_rxF$sFULL_N && rxRS_rxOperateS$dD_OUT && rxRS_rxDVD &&
	     rxRS_rxAPipe[5] ;

  // rule RL_rxRS_ingress_advance
  assign WILL_FIRE_RL_rxRS_ingress_advance =
	     rxRS_rxOperateS$dD_OUT && rxRS_rxDV && !rxRS_rxER ;

  // rule RL_rxRS_end_frame
  assign WILL_FIRE_RL_rxRS_end_frame =
	     rxRS_rxOperateS$dD_OUT && (rxRS_crcEnd || rxRS_rxER) &&
	     !WILL_FIRE_RL_rxRS_ingress_noadvance ;

  // rule RL_rxRS_crcDbgCnt_ruleInc
  assign WILL_FIRE_RL_rxRS_crcDbgCnt_ruleInc =
	     rxRS_crcDbgCnt_incAction$whas &&
	     !WILL_FIRE_RL_rxRS_ingress_noadvance ;

  // rule RL_txRS_egress_SOF
  assign CAN_FIRE_RL_txRS_egress_SOF =
	     txRS_txF$dEMPTY_N &&
	     (txRS_preambleCnt_value_19_ULT_7___d183 ||
	      txRS_preambleCnt_value == 5'd7 ||
	      txRS_txF$dEMPTY_N) &&
	     txRS_txOperateS$dD_OUT &&
	     txRS_isSOF &&
	     txRS_ifgCnt_value == 5'h0 &&
	     txRS_txF$dD_OUT[9:8] == 2'd0 ;
  assign WILL_FIRE_RL_txRS_egress_SOF =
	     CAN_FIRE_RL_txRS_egress_SOF && !WILL_FIRE_RL_txRS_egress_FCS ;

  // rule RL_txRS_egress_Body
  assign CAN_FIRE_RL_txRS_egress_Body =
	     txRS_txF$dEMPTY_N && txRS_txOperateS$dD_OUT && txRS_txActive &&
	     !txRS_isSOF &&
	     txRS_txF$dD_OUT[9:8] == 2'd0 ;
  assign WILL_FIRE_RL_txRS_egress_Body =
	     CAN_FIRE_RL_txRS_egress_Body && !WILL_FIRE_RL_txRS_egress_FCS ;

  // rule RL_txRS_egress_EOF
  assign CAN_FIRE_RL_txRS_egress_EOF =
	     txRS_txF$dEMPTY_N &&
	     (txRS_lenCnt_value_45_ULT_59___d209 || txRS_txF$dEMPTY_N) &&
	     txRS_txOperateS$dD_OUT &&
	     txRS_txActive &&
	     txRS_txF$dD_OUT[9:8] == 2'd1 ;
  assign WILL_FIRE_RL_txRS_egress_EOF =
	     CAN_FIRE_RL_txRS_egress_EOF && !WILL_FIRE_RL_txRS_egress_FCS ;

  // rule RL_txRS_egress_FCS
  assign WILL_FIRE_RL_txRS_egress_FCS =
	     txRS_txOperateS$dD_OUT && txRS_emitFCS != 3'd0 ;

  // inputs to muxes for submodule ports
  assign MUX_rxRS_rxF$enq_1__SEL_1 =
	     WILL_FIRE_RL_rxRS_ingress_noadvance && rxRS_rxActive ;
  assign MUX_txRS_crc$add_1__SEL_1 =
	     WILL_FIRE_RL_txRS_egress_SOF &&
	     !txRS_preambleCnt_value_19_ULT_7___d183 &&
	     txRS_preambleCnt_value != 5'd7 ;
  assign MUX_txRS_crcDbgCnt_value$write_1__SEL_1 =
	     WILL_FIRE_RL_txRS_egress_FCS && txRS_emitFCS == 3'd4 ;
  assign MUX_txRS_emitFCS$write_1__SEL_1 =
	     WILL_FIRE_RL_txRS_egress_EOF &&
	     !txRS_lenCnt_value_45_ULT_59___d209 ;
  assign MUX_txRS_ifgCnt_value$write_1__SEL_1 =
	     WILL_FIRE_RL_txRS_egress_FCS && txRS_emitFCS == 3'd1 ;
  assign MUX_rxRS_crcDbgCnt_value$write_1__VAL_1 =
	     (rxRS_crcDbgCnt_value == 12'd4095) ?
	       rxRS_crcDbgCnt_value :
	       rxRS_crcDbgCnt_value + 12'd1 ;
  assign MUX_rxRS_preambleCnt_value$write_1__VAL_3 =
	     (rxRS_preambleCnt_value == 4'd15) ?
	       rxRS_preambleCnt_value :
	       rxRS_preambleCnt_value + 4'd1 ;
  assign MUX_rxRS_rxAPipe$write_1__VAL_2 =
	     { rxRS_rxAPipe[4:0], rxRS_rxActive } ;
  assign MUX_rxRS_rxF$enq_1__VAL_1 =
	     (rxRS_crc$complete ==
	      { rxRS_rxPipe[7:0],
		rxRS_rxPipe[15:8],
		rxRS_rxPipe[23:16],
		rxRS_rxPipe[31:24] }) ?
	       { 2'd1, rxRS_rxPipe[39:32] } :
	       { 2'd3, rxRS_rxPipe[39:32] } ;
  assign MUX_rxRS_rxF$enq_1__VAL_2 =
	     rxRS_rxER ?
	       { 2'd3, rxRS_rxPipe[47:40] } :
	       { 2'd0, rxRS_rxPipe[47:40] } ;
  assign MUX_txRS_crc$add_1__VAL_2 =
	     txRS_doPad ? 8'd0 : txRS_txF$dD_OUT[7:0] ;
  assign MUX_txRS_crcDbgCnt_value$write_1__VAL_2 =
	     (txRS_crcDbgCnt_value == 12'd4095) ?
	       txRS_crcDbgCnt_value :
	       txRS_crcDbgCnt_value + 12'd1 ;
  assign MUX_txRS_ifgCnt_value$write_1__VAL_2 =
	     (txRS_ifgCnt_value == 5'h0) ?
	       txRS_ifgCnt_value :
	       txRS_ifgCnt_value - 5'd1 ;
  assign MUX_txRS_lenCnt_value$write_1__VAL_2 =
	     (txRS_lenCnt_value == 12'd4095) ?
	       txRS_lenCnt_value :
	       txRS_lenCnt_value + 12'd1 ;
  assign MUX_txRS_preambleCnt_value$write_1__VAL_3 =
	     (txRS_preambleCnt_value == 5'd31) ?
	       txRS_preambleCnt_value :
	       txRS_preambleCnt_value + 5'd1 ;
  always@(x__h13660 or txRS_crc$result)
  begin
    case (x__h13660)
      3'd0: MUX_txRS_txData_1$wset_1__VAL_1 = txRS_crc$result[31:24];
      3'd1: MUX_txRS_txData_1$wset_1__VAL_1 = txRS_crc$result[23:16];
      3'd2: MUX_txRS_txData_1$wset_1__VAL_1 = txRS_crc$result[15:8];
      3'd3: MUX_txRS_txData_1$wset_1__VAL_1 = txRS_crc$result[7:0];
      default: MUX_txRS_txData_1$wset_1__VAL_1 =
		   8'b10101010 /* unspecified value */ ;
    endcase
  end
  assign MUX_txRS_txData_1$wset_1__VAL_4 =
	     txRS_preambleCnt_value_19_ULT_7___d183 ?
	       8'd85 :
	       ((txRS_preambleCnt_value == 5'd7) ?
		  8'd213 :
		  txRS_txF$dD_OUT[7:0]) ;

  // inlined wires
  assign rxRS_rxOperateD_1$wget = 1'd1 ;
  assign rxRS_rxOperateD_1$whas = EN_rxOperate ;
  assign txRS_txOperateD_1$wget = 1'd1 ;
  assign txRS_txOperateD_1$whas = EN_txOperate ;
  always@(WILL_FIRE_RL_txRS_egress_FCS or
	  MUX_txRS_txData_1$wset_1__VAL_1 or
	  WILL_FIRE_RL_txRS_egress_EOF or
	  MUX_txRS_crc$add_1__VAL_2 or
	  WILL_FIRE_RL_txRS_egress_Body or
	  txRS_txF$dD_OUT or
	  WILL_FIRE_RL_txRS_egress_SOF or MUX_txRS_txData_1$wset_1__VAL_4)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_txRS_egress_FCS:
	  txRS_txData_1$wget = MUX_txRS_txData_1$wset_1__VAL_1;
      WILL_FIRE_RL_txRS_egress_EOF:
	  txRS_txData_1$wget = MUX_txRS_crc$add_1__VAL_2;
      WILL_FIRE_RL_txRS_egress_Body:
	  txRS_txData_1$wget = txRS_txF$dD_OUT[7:0];
      WILL_FIRE_RL_txRS_egress_SOF:
	  txRS_txData_1$wget = MUX_txRS_txData_1$wset_1__VAL_4;
      default: txRS_txData_1$wget = 8'b10101010 /* unspecified value */ ;
    endcase
  end
  assign txRS_txData_1$whas =
	     WILL_FIRE_RL_txRS_egress_FCS || WILL_FIRE_RL_txRS_egress_EOF ||
	     WILL_FIRE_RL_txRS_egress_Body ||
	     WILL_FIRE_RL_txRS_egress_SOF ;
  assign txRS_txDV_1$wget = 1'd1 ;
  assign txRS_txDV_1$whas =
	     WILL_FIRE_RL_txRS_egress_SOF || WILL_FIRE_RL_txRS_egress_Body ||
	     WILL_FIRE_RL_txRS_egress_EOF ||
	     WILL_FIRE_RL_txRS_egress_FCS ;
  assign txRS_txER_1$wget = 1'b0 ;
  assign txRS_txER_1$whas = 1'b0 ;
  assign txRS_underflow_1$wget = 1'b0 ;
  assign txRS_underflow_1$whas = 1'b0 ;
  assign rxRS_preambleCnt_incAction$whas =
	     WILL_FIRE_RL_rxRS_ingress_advance && rxRS_rxData == 8'd85 ;
  assign rxRS_preambleCnt_decAction$whas = 1'b0 ;
  assign rxRS_crcDbgCnt_incAction$whas =
	     rxRS_rxOperateS$dD_OUT && rxRS_rxDV && rxRS_rxAPipe[3] ;
  assign rxRS_crcDbgCnt_decAction$whas = 1'b0 ;
  assign txRS_preambleCnt_incAction$whas = WILL_FIRE_RL_txRS_egress_SOF ;
  assign txRS_preambleCnt_decAction$whas = 1'b0 ;
  assign txRS_ifgCnt_incAction$whas = 1'b0 ;
  assign txRS_ifgCnt_decAction$whas =
	     txRS_txOperateS$dD_OUT && txRS_ifgCnt_value != 5'h0 ;
  assign txRS_lenCnt_incAction$whas =
	     WILL_FIRE_RL_txRS_egress_SOF &&
	     !txRS_preambleCnt_value_19_ULT_7___d183 &&
	     txRS_preambleCnt_value != 5'd7 ||
	     WILL_FIRE_RL_txRS_egress_Body ||
	     WILL_FIRE_RL_txRS_egress_EOF ||
	     WILL_FIRE_RL_txRS_egress_FCS ;
  assign txRS_lenCnt_decAction$whas = 1'b0 ;
  assign txRS_crcDbgCnt_incAction$whas =
	     WILL_FIRE_RL_txRS_egress_SOF &&
	     !txRS_preambleCnt_value_19_ULT_7___d183 &&
	     txRS_preambleCnt_value != 5'd7 ||
	     WILL_FIRE_RL_txRS_egress_Body ||
	     WILL_FIRE_RL_txRS_egress_EOF ;
  assign txRS_crcDbgCnt_decAction$whas = 1'b0 ;

  // register gmacLED
  assign gmacLED$D_IN = 1'd1 ;
  assign gmacLED$EN = EN_rxOperate ;

  // register rxRS_crcDbgCnt_value
  assign rxRS_crcDbgCnt_value$D_IN =
	     WILL_FIRE_RL_rxRS_crcDbgCnt_ruleInc ?
	       MUX_rxRS_crcDbgCnt_value$write_1__VAL_1 :
	       12'd0 ;
  assign rxRS_crcDbgCnt_value$EN =
	     WILL_FIRE_RL_rxRS_crcDbgCnt_ruleInc ||
	     WILL_FIRE_RL_rxRS_ingress_noadvance ;

  // register rxRS_crcEnd
  assign rxRS_crcEnd$D_IN = !WILL_FIRE_RL_rxRS_end_frame ;
  assign rxRS_crcEnd$EN =
	     WILL_FIRE_RL_rxRS_end_frame ||
	     WILL_FIRE_RL_rxRS_ingress_noadvance ;

  // register rxRS_fullD
  assign rxRS_fullD$D_IN = rxRS_rxOperateS$dD_OUT && !rxRS_rxF$sFULL_N ;
  assign rxRS_fullD$EN = 1'd1 ;

  // register rxRS_isSOF
  assign rxRS_isSOF$D_IN = WILL_FIRE_RL_rxRS_end_frame ;
  assign rxRS_isSOF$EN =
	     WILL_FIRE_RL_rxRS_egress_data || WILL_FIRE_RL_rxRS_end_frame ;

  // register rxRS_preambleCnt_value
  assign rxRS_preambleCnt_value$D_IN =
	     WILL_FIRE_RL_rxRS_end_frame ?
	       4'd0 :
	       MUX_rxRS_preambleCnt_value$write_1__VAL_3 ;
  assign rxRS_preambleCnt_value$EN =
	     rxRS_preambleCnt_incAction$whas || WILL_FIRE_RL_rxRS_end_frame ;

  // register rxRS_rxAPipe
  assign rxRS_rxAPipe$D_IN =
	     WILL_FIRE_RL_rxRS_end_frame ?
	       6'd0 :
	       MUX_rxRS_rxAPipe$write_1__VAL_2 ;
  assign rxRS_rxAPipe$EN =
	     WILL_FIRE_RL_rxRS_ingress_advance ||
	     WILL_FIRE_RL_rxRS_end_frame ;

  // register rxRS_rxActive
  assign rxRS_rxActive$D_IN = !WILL_FIRE_RL_rxRS_end_frame ;
  assign rxRS_rxActive$EN =
	     WILL_FIRE_RL_rxRS_ingress_advance &&
	     rxRS_preambleCnt_value > 4'd6 &&
	     rxRS_rxData == 8'd213 ||
	     WILL_FIRE_RL_rxRS_end_frame ;

  // register rxRS_rxDV
  assign rxRS_rxDV$D_IN = gmii_rx_rx_dv_i ;
  assign rxRS_rxDV$EN = 1'd1 ;

  // register rxRS_rxDVD
  assign rxRS_rxDVD$D_IN = rxRS_rxDV ;
  assign rxRS_rxDVD$EN = rxRS_rxOperateS$dD_OUT ;

  // register rxRS_rxDVD2
  assign rxRS_rxDVD2$D_IN = rxRS_rxDVD ;
  assign rxRS_rxDVD2$EN = rxRS_rxOperateS$dD_OUT ;

  // register rxRS_rxData
  assign rxRS_rxData$D_IN = gmii_rx_rxd_i ;
  assign rxRS_rxData$EN = 1'd1 ;

  // register rxRS_rxER
  assign rxRS_rxER$D_IN = gmii_rx_rx_er_i ;
  assign rxRS_rxER$EN = 1'd1 ;

  // register rxRS_rxOperateD
  assign rxRS_rxOperateD$D_IN = EN_rxOperate ;
  assign rxRS_rxOperateD$EN = 1'd1 ;

  // register rxRS_rxPipe
  assign rxRS_rxPipe$D_IN = { rxRS_rxPipe[39:0], rxRS_rxData } ;
  assign rxRS_rxPipe$EN = WILL_FIRE_RL_rxRS_ingress_advance ;

  // register txRS_crcDbgCnt_value
  assign txRS_crcDbgCnt_value$D_IN =
	     MUX_txRS_crcDbgCnt_value$write_1__SEL_1 ?
	       12'd0 :
	       MUX_txRS_crcDbgCnt_value$write_1__VAL_2 ;
  assign txRS_crcDbgCnt_value$EN =
	     WILL_FIRE_RL_txRS_egress_FCS && txRS_emitFCS == 3'd4 ||
	     txRS_crcDbgCnt_incAction$whas && !WILL_FIRE_RL_txRS_egress_FCS ;

  // register txRS_doPad
  assign txRS_doPad$D_IN = txRS_lenCnt_value_45_ULT_59___d209 ;
  assign txRS_doPad$EN = WILL_FIRE_RL_txRS_egress_EOF ;

  // register txRS_emitFCS
  assign txRS_emitFCS$D_IN =
	     MUX_txRS_emitFCS$write_1__SEL_1 ? 3'd4 : x__h13660 ;
  assign txRS_emitFCS$EN =
	     WILL_FIRE_RL_txRS_egress_EOF &&
	     !txRS_lenCnt_value_45_ULT_59___d209 ||
	     WILL_FIRE_RL_txRS_egress_FCS ;

  // register txRS_ifgCnt_value
  assign txRS_ifgCnt_value$D_IN =
	     MUX_txRS_ifgCnt_value$write_1__SEL_1 ?
	       5'd12 :
	       MUX_txRS_ifgCnt_value$write_1__VAL_2 ;
  assign txRS_ifgCnt_value$EN =
	     WILL_FIRE_RL_txRS_egress_FCS && txRS_emitFCS == 3'd1 ||
	     txRS_ifgCnt_decAction$whas ;

  // register txRS_isSOF
  assign txRS_isSOF$D_IN = !MUX_txRS_crc$add_1__SEL_1 ;
  assign txRS_isSOF$EN =
	     WILL_FIRE_RL_txRS_egress_SOF &&
	     !txRS_preambleCnt_value_19_ULT_7___d183 &&
	     txRS_preambleCnt_value != 5'd7 ||
	     WILL_FIRE_RL_txRS_egress_FCS && txRS_emitFCS == 3'd1 ;

  // register txRS_lenCnt_value
  assign txRS_lenCnt_value$D_IN =
	     MUX_txRS_ifgCnt_value$write_1__SEL_1 ?
	       12'd0 :
	       MUX_txRS_lenCnt_value$write_1__VAL_2 ;
  assign txRS_lenCnt_value$EN =
	     WILL_FIRE_RL_txRS_egress_FCS && txRS_emitFCS == 3'd1 ||
	     txRS_lenCnt_incAction$whas && !WILL_FIRE_RL_txRS_egress_FCS ;

  // register txRS_preambleCnt_value
  assign txRS_preambleCnt_value$D_IN =
	     MUX_txRS_ifgCnt_value$write_1__SEL_1 ?
	       5'd0 :
	       MUX_txRS_preambleCnt_value$write_1__VAL_3 ;
  assign txRS_preambleCnt_value$EN =
	     WILL_FIRE_RL_txRS_egress_FCS && txRS_emitFCS == 3'd1 ||
	     WILL_FIRE_RL_txRS_egress_SOF ;

  // register txRS_txActive
  assign txRS_txActive$D_IN = !MUX_txRS_emitFCS$write_1__SEL_1 ;
  assign txRS_txActive$EN =
	     WILL_FIRE_RL_txRS_egress_EOF &&
	     !txRS_lenCnt_value_45_ULT_59___d209 ||
	     WILL_FIRE_RL_txRS_egress_SOF ;

  // register txRS_txDV
  assign txRS_txDV$D_IN = txRS_txDV_1$whas ;
  assign txRS_txDV$EN = 1'd1 ;

  // register txRS_txData
  assign txRS_txData$D_IN = txRS_txData_1$whas ? txRS_txData_1$wget : 8'd0 ;
  assign txRS_txData$EN = 1'd1 ;

  // register txRS_txER
  assign txRS_txER$D_IN = 1'b0 ;
  assign txRS_txER$EN = 1'd1 ;

  // register txRS_txOperateD
  assign txRS_txOperateD$D_IN = EN_txOperate ;
  assign txRS_txOperateD$EN = 1'd1 ;

  // register txRS_underflow
  assign txRS_underflow$D_IN = 1'b0 ;
  assign txRS_underflow$EN = 1'd1 ;

  // register txRS_unfD
  assign txRS_unfD$D_IN =
	     txRS_txOperateS$dD_OUT && !txRS_txF$dEMPTY_N && txRS_txActive &&
	     !txRS_doPad ;
  assign txRS_unfD$EN = 1'd1 ;

  // submodule col_cc
  assign col_cc$sD_IN = gmii_col_i ;
  assign col_cc$sEN = 1'd1 ;

  // submodule crs_cc
  assign crs_cc$sD_IN = gmii_crs_i ;
  assign crs_cc$sEN = 1'd1 ;

  // submodule intr_cc
  assign intr_cc$sD_IN = gmii_intr_i ;
  assign intr_cc$sEN = 1'd1 ;

  // submodule rxRS_crc
  assign rxRS_crc$add_data = rxRS_rxPipe[31:24] ;
  assign rxRS_crc$EN_add =
	     rxRS_rxOperateS$dD_OUT && rxRS_rxDV && rxRS_rxAPipe[3] ;
  assign rxRS_crc$EN_clear = 1'b0 ;
  assign rxRS_crc$EN_complete = WILL_FIRE_RL_rxRS_ingress_noadvance ;

  // submodule rxRS_ovfBit
  assign rxRS_ovfBit$sD_IN =
	     rxRS_rxOperateS$dD_OUT && (!rxRS_rxF$sFULL_N || rxRS_fullD) ;
  assign rxRS_ovfBit$sEN = rxRS_rxOperateS$dD_OUT ;

  // submodule rxRS_rxF
  assign rxRS_rxF$sD_IN =
	     MUX_rxRS_rxF$enq_1__SEL_1 ?
	       MUX_rxRS_rxF$enq_1__VAL_1 :
	       MUX_rxRS_rxF$enq_1__VAL_2 ;
  assign rxRS_rxF$sENQ =
	     WILL_FIRE_RL_rxRS_ingress_noadvance && rxRS_rxActive ||
	     WILL_FIRE_RL_rxRS_egress_data ;
  assign rxRS_rxF$dDEQ = EN_rx_get ;

  // submodule rxRS_rxOperateS
  assign rxRS_rxOperateS$sD_IN = rxRS_rxOperateD ;
  assign rxRS_rxOperateS$sEN = 1'd1 ;

  // submodule txRS_crc
  assign txRS_crc$add_data =
	     (MUX_txRS_crc$add_1__SEL_1 || WILL_FIRE_RL_txRS_egress_Body) ?
	       txRS_txF$dD_OUT[7:0] :
	       MUX_txRS_crc$add_1__VAL_2 ;
  assign txRS_crc$EN_add =
	     WILL_FIRE_RL_txRS_egress_SOF &&
	     !txRS_preambleCnt_value_19_ULT_7___d183 &&
	     txRS_preambleCnt_value != 5'd7 ||
	     WILL_FIRE_RL_txRS_egress_EOF ||
	     WILL_FIRE_RL_txRS_egress_Body ;
  assign txRS_crc$EN_clear = MUX_txRS_ifgCnt_value$write_1__SEL_1 ;
  assign txRS_crc$EN_complete = 1'b0 ;

  // submodule txRS_iobTxData
  assign txRS_iobTxData$CE = 1'd1 ;
  assign txRS_iobTxData$D1 = txRS_txData[0] ;
  assign txRS_iobTxData$D2 = txRS_txData[0] ;
  assign txRS_iobTxData$S = 1'd0 ;

  // submodule txRS_iobTxData_1
  assign txRS_iobTxData_1$CE = 1'd1 ;
  assign txRS_iobTxData_1$D1 = txRS_txData[1] ;
  assign txRS_iobTxData_1$D2 = txRS_txData[1] ;
  assign txRS_iobTxData_1$S = 1'd0 ;

  // submodule txRS_iobTxData_2
  assign txRS_iobTxData_2$CE = 1'd1 ;
  assign txRS_iobTxData_2$D1 = txRS_txData[2] ;
  assign txRS_iobTxData_2$D2 = txRS_txData[2] ;
  assign txRS_iobTxData_2$S = 1'd0 ;

  // submodule txRS_iobTxData_3
  assign txRS_iobTxData_3$CE = 1'd1 ;
  assign txRS_iobTxData_3$D1 = txRS_txData[3] ;
  assign txRS_iobTxData_3$D2 = txRS_txData[3] ;
  assign txRS_iobTxData_3$S = 1'd0 ;

  // submodule txRS_iobTxData_4
  assign txRS_iobTxData_4$CE = 1'd1 ;
  assign txRS_iobTxData_4$D1 = txRS_txData[4] ;
  assign txRS_iobTxData_4$D2 = txRS_txData[4] ;
  assign txRS_iobTxData_4$S = 1'd0 ;

  // submodule txRS_iobTxData_5
  assign txRS_iobTxData_5$CE = 1'd1 ;
  assign txRS_iobTxData_5$D1 = txRS_txData[5] ;
  assign txRS_iobTxData_5$D2 = txRS_txData[5] ;
  assign txRS_iobTxData_5$S = 1'd0 ;

  // submodule txRS_iobTxData_6
  assign txRS_iobTxData_6$CE = 1'd1 ;
  assign txRS_iobTxData_6$D1 = txRS_txData[6] ;
  assign txRS_iobTxData_6$D2 = txRS_txData[6] ;
  assign txRS_iobTxData_6$S = 1'd0 ;

  // submodule txRS_iobTxData_7
  assign txRS_iobTxData_7$CE = 1'd1 ;
  assign txRS_iobTxData_7$D1 = txRS_txData[7] ;
  assign txRS_iobTxData_7$D2 = txRS_txData[7] ;
  assign txRS_iobTxData_7$S = 1'd0 ;

  // submodule txRS_iobTxEna
  assign txRS_iobTxEna$CE = 1'd1 ;
  assign txRS_iobTxEna$D1 = txRS_txDV ;
  assign txRS_iobTxEna$D2 = txRS_txDV ;
  assign txRS_iobTxEna$S = 1'd0 ;

  // submodule txRS_iobTxErr
  assign txRS_iobTxErr$CE = 1'd1 ;
  assign txRS_iobTxErr$D1 = txRS_txER ;
  assign txRS_iobTxErr$D2 = txRS_txER ;
  assign txRS_iobTxErr$S = 1'd0 ;

  // submodule txRS_txF
  assign txRS_txF$sD_IN =
	     { CASE_tx_put_BITS_9_TO_8_0_tx_put_BITS_9_TO_8_1_ETC__q2,
	       tx_put[7:0] } ;
  assign txRS_txF$sENQ = EN_tx_put ;
  assign txRS_txF$dDEQ =
	     WILL_FIRE_RL_txRS_egress_SOF &&
	     !txRS_preambleCnt_value_19_ULT_7___d183 &&
	     txRS_preambleCnt_value != 5'd7 ||
	     WILL_FIRE_RL_txRS_egress_EOF &&
	     !txRS_lenCnt_value_45_ULT_59___d209 ||
	     WILL_FIRE_RL_txRS_egress_Body ;

  // submodule txRS_txOperateS
  assign txRS_txOperateS$sD_IN = txRS_txOperateD ;
  assign txRS_txOperateS$sEN = 1'd1 ;

  // submodule txRS_unfBit
  assign txRS_unfBit$sD_IN =
	     txRS_txOperateS$dD_OUT && !txRS_txF$dEMPTY_N && txRS_txActive &&
	     !txRS_doPad ||
	     txRS_unfD ;
  assign txRS_unfBit$sEN = txRS_txOperateS$dD_OUT ;

  // remaining internal signals
  assign txRS_lenCnt_value_45_ULT_59___d209 = txRS_lenCnt_value < 12'd59 ;
  assign txRS_preambleCnt_value_19_ULT_7___d183 =
	     txRS_preambleCnt_value < 5'd7 ;
  assign x__h13660 = txRS_emitFCS - 3'd1 ;
  always@(rxRS_rxF$dD_OUT)
  begin
    case (rxRS_rxF$dD_OUT[9:8])
      2'd0, 2'd1, 2'd2:
	  CASE_rxRS_rxFdD_OUT_BITS_9_TO_8_0_rxRS_rxFdD_ETC__q1 =
	      rxRS_rxF$dD_OUT[9:8];
      2'd3: CASE_rxRS_rxFdD_OUT_BITS_9_TO_8_0_rxRS_rxFdD_ETC__q1 = 2'd3;
    endcase
  end
  always@(tx_put)
  begin
    case (tx_put[9:8])
      2'd0, 2'd1, 2'd2:
	  CASE_tx_put_BITS_9_TO_8_0_tx_put_BITS_9_TO_8_1_ETC__q2 =
	      tx_put[9:8];
      2'd3: CASE_tx_put_BITS_9_TO_8_0_tx_put_BITS_9_TO_8_1_ETC__q2 = 2'd3;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        gmacLED <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rxRS_rxOperateD <= `BSV_ASSIGNMENT_DELAY 1'd0;
	txRS_txOperateD <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (gmacLED$EN) gmacLED <= `BSV_ASSIGNMENT_DELAY gmacLED$D_IN;
	if (rxRS_rxOperateD$EN)
	  rxRS_rxOperateD <= `BSV_ASSIGNMENT_DELAY rxRS_rxOperateD$D_IN;
	if (txRS_txOperateD$EN)
	  txRS_txOperateD <= `BSV_ASSIGNMENT_DELAY txRS_txOperateD$D_IN;
      end
  end

  always@(posedge CLK_txClk)
  begin
    if (txRS_txRst$OUT_RST == `BSV_RESET_VALUE)
      begin
        txRS_crcDbgCnt_value <= `BSV_ASSIGNMENT_DELAY 12'd0;
	txRS_doPad <= `BSV_ASSIGNMENT_DELAY 1'd0;
	txRS_emitFCS <= `BSV_ASSIGNMENT_DELAY 3'd0;
	txRS_ifgCnt_value <= `BSV_ASSIGNMENT_DELAY 5'd0;
	txRS_isSOF <= `BSV_ASSIGNMENT_DELAY 1'd1;
	txRS_lenCnt_value <= `BSV_ASSIGNMENT_DELAY 12'd0;
	txRS_preambleCnt_value <= `BSV_ASSIGNMENT_DELAY 5'd0;
	txRS_txActive <= `BSV_ASSIGNMENT_DELAY 1'd0;
	txRS_txDV <= `BSV_ASSIGNMENT_DELAY 1'd0;
	txRS_txData <= `BSV_ASSIGNMENT_DELAY 8'd0;
	txRS_txER <= `BSV_ASSIGNMENT_DELAY 1'd0;
	txRS_underflow <= `BSV_ASSIGNMENT_DELAY 1'd0;
	txRS_unfD <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (txRS_crcDbgCnt_value$EN)
	  txRS_crcDbgCnt_value <= `BSV_ASSIGNMENT_DELAY
	      txRS_crcDbgCnt_value$D_IN;
	if (txRS_doPad$EN)
	  txRS_doPad <= `BSV_ASSIGNMENT_DELAY txRS_doPad$D_IN;
	if (txRS_emitFCS$EN)
	  txRS_emitFCS <= `BSV_ASSIGNMENT_DELAY txRS_emitFCS$D_IN;
	if (txRS_ifgCnt_value$EN)
	  txRS_ifgCnt_value <= `BSV_ASSIGNMENT_DELAY txRS_ifgCnt_value$D_IN;
	if (txRS_isSOF$EN)
	  txRS_isSOF <= `BSV_ASSIGNMENT_DELAY txRS_isSOF$D_IN;
	if (txRS_lenCnt_value$EN)
	  txRS_lenCnt_value <= `BSV_ASSIGNMENT_DELAY txRS_lenCnt_value$D_IN;
	if (txRS_preambleCnt_value$EN)
	  txRS_preambleCnt_value <= `BSV_ASSIGNMENT_DELAY
	      txRS_preambleCnt_value$D_IN;
	if (txRS_txActive$EN)
	  txRS_txActive <= `BSV_ASSIGNMENT_DELAY txRS_txActive$D_IN;
	if (txRS_txDV$EN) txRS_txDV <= `BSV_ASSIGNMENT_DELAY txRS_txDV$D_IN;
	if (txRS_txData$EN)
	  txRS_txData <= `BSV_ASSIGNMENT_DELAY txRS_txData$D_IN;
	if (txRS_txER$EN) txRS_txER <= `BSV_ASSIGNMENT_DELAY txRS_txER$D_IN;
	if (txRS_underflow$EN)
	  txRS_underflow <= `BSV_ASSIGNMENT_DELAY txRS_underflow$D_IN;
	if (txRS_unfD$EN) txRS_unfD <= `BSV_ASSIGNMENT_DELAY txRS_unfD$D_IN;
      end
  end

  always@(posedge rxClk_BUFR$O)
  begin
    if (rxRS_rxRst$OUT_RST == `BSV_RESET_VALUE)
      begin
        rxRS_crcDbgCnt_value <= `BSV_ASSIGNMENT_DELAY 12'd0;
	rxRS_crcEnd <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rxRS_fullD <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rxRS_isSOF <= `BSV_ASSIGNMENT_DELAY 1'd1;
	rxRS_preambleCnt_value <= `BSV_ASSIGNMENT_DELAY 4'd0;
	rxRS_rxAPipe <= `BSV_ASSIGNMENT_DELAY 6'd0;
	rxRS_rxActive <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rxRS_rxDV <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rxRS_rxDVD <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rxRS_rxDVD2 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rxRS_rxER <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (rxRS_crcDbgCnt_value$EN)
	  rxRS_crcDbgCnt_value <= `BSV_ASSIGNMENT_DELAY
	      rxRS_crcDbgCnt_value$D_IN;
	if (rxRS_crcEnd$EN)
	  rxRS_crcEnd <= `BSV_ASSIGNMENT_DELAY rxRS_crcEnd$D_IN;
	if (rxRS_fullD$EN)
	  rxRS_fullD <= `BSV_ASSIGNMENT_DELAY rxRS_fullD$D_IN;
	if (rxRS_isSOF$EN)
	  rxRS_isSOF <= `BSV_ASSIGNMENT_DELAY rxRS_isSOF$D_IN;
	if (rxRS_preambleCnt_value$EN)
	  rxRS_preambleCnt_value <= `BSV_ASSIGNMENT_DELAY
	      rxRS_preambleCnt_value$D_IN;
	if (rxRS_rxAPipe$EN)
	  rxRS_rxAPipe <= `BSV_ASSIGNMENT_DELAY rxRS_rxAPipe$D_IN;
	if (rxRS_rxActive$EN)
	  rxRS_rxActive <= `BSV_ASSIGNMENT_DELAY rxRS_rxActive$D_IN;
	if (rxRS_rxDV$EN) rxRS_rxDV <= `BSV_ASSIGNMENT_DELAY rxRS_rxDV$D_IN;
	if (rxRS_rxDVD$EN)
	  rxRS_rxDVD <= `BSV_ASSIGNMENT_DELAY rxRS_rxDVD$D_IN;
	if (rxRS_rxDVD2$EN)
	  rxRS_rxDVD2 <= `BSV_ASSIGNMENT_DELAY rxRS_rxDVD2$D_IN;
	if (rxRS_rxER$EN) rxRS_rxER <= `BSV_ASSIGNMENT_DELAY rxRS_rxER$D_IN;
      end
    if (rxRS_rxData$EN) rxRS_rxData <= `BSV_ASSIGNMENT_DELAY rxRS_rxData$D_IN;
    if (rxRS_rxPipe$EN) rxRS_rxPipe <= `BSV_ASSIGNMENT_DELAY rxRS_rxPipe$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    gmacLED = 1'h0;
    rxRS_crcDbgCnt_value = 12'hAAA;
    rxRS_crcEnd = 1'h0;
    rxRS_fullD = 1'h0;
    rxRS_isSOF = 1'h0;
    rxRS_preambleCnt_value = 4'hA;
    rxRS_rxAPipe = 6'h2A;
    rxRS_rxActive = 1'h0;
    rxRS_rxDV = 1'h0;
    rxRS_rxDVD = 1'h0;
    rxRS_rxDVD2 = 1'h0;
    rxRS_rxData = 8'hAA;
    rxRS_rxER = 1'h0;
    rxRS_rxOperateD = 1'h0;
    rxRS_rxPipe = 48'hAAAAAAAAAAAA;
    txRS_crcDbgCnt_value = 12'hAAA;
    txRS_doPad = 1'h0;
    txRS_emitFCS = 3'h2;
    txRS_ifgCnt_value = 5'h0A;
    txRS_isSOF = 1'h0;
    txRS_lenCnt_value = 12'hAAA;
    txRS_preambleCnt_value = 5'h0A;
    txRS_txActive = 1'h0;
    txRS_txDV = 1'h0;
    txRS_txData = 8'hAA;
    txRS_txER = 1'h0;
    txRS_txOperateD = 1'h0;
    txRS_underflow = 1'h0;
    txRS_unfD = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK_txClk)
  begin
    #0;
    if (txRS_txRst$OUT_RST != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_txRS_egress_FCS && txRS_emitFCS == 3'd4)
	begin
	  v__h12643 = $time;
	  #0;
	end
    if (txRS_txRst$OUT_RST != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_txRS_egress_FCS && txRS_emitFCS == 3'd4)
	$display("[%0d]: %m: TX FCS:%08x from %d elements",
		 v__h12643,
		 { txRS_crc$result[7:0],
		   txRS_crc$result[15:8],
		   txRS_crc$result[23:16],
		   txRS_crc$result[31:24] },
		 $unsigned(txRS_crcDbgCnt_value));
  end
  // synopsys translate_on

  // synopsys translate_off
  always@(negedge rxClk_BUFR$O or
	  negedge gmii_rx_clk$O or negedge gmii_rxc_dly$DATAOUT)
  begin
    #0;
    if (rxRS_rxRst$OUT_RST != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rxRS_ingress_noadvance)
	begin
	  v__h6699 = $time;
	  #0;
	end
    if (rxRS_rxRst$OUT_RST != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rxRS_ingress_noadvance)
	$display("[%0d]: %m: RX FCS:%08x from %d elements",
		 v__h6699,
		 rxRS_crc$complete,
		 $unsigned(rxRS_crcDbgCnt_value));
  end
  // synopsys translate_on
endmodule  // mkGMAC
