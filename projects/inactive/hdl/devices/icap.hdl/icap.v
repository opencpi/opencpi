/*
 * This file is protected by Copyright. Please refer to the COPYRIGHT file
 * distributed with this source distribution.
 *
 * This file is part of OpenCPI <http://www.opencpi.org>
 *
 * OpenCPI is free software: you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * OpenCPI is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

//
// Generated by Bluespec Compiler, version 2012.09.beta1 (build 29570, 2012-09.11)
//
// On Wed Oct 24 10:25:15 EDT 2012
//
//
// Ports:
// Name                         I/O  size props
// wciS0_SResp                    O     2 reg
// wciS0_SData                    O    32 reg
// wciS0_SThreadBusy              O     1
// wciS0_SFlag                    O     2
// wciS0_Clk                      I     1 clock
// wciS0_MReset_n                 I     1 reset
// wciS0_MCmd                     I     3
// wciS0_MAddrSpace               I     1
// wciS0_MByteEn                  I     4
// wciS0_MAddr                    I    32
// wciS0_MData                    I    32
// wciS0_MFlag                    I     2 unused
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

`ifdef ORIGINAL
module mkICAPWorker(wciS0_Clk,
		    wciS0_MReset_n,

		    wciS0_MCmd,

		    wciS0_MAddrSpace,

		    wciS0_MByteEn,

		    wciS0_MAddr,

		    wciS0_MData,

		    wciS0_SResp,

		    wciS0_SData,

		    wciS0_SThreadBusy,

		    wciS0_SFlag,

		    wciS0_MFlag);
  parameter icapPrim = "";
  parameter [0 : 0] hasDebugLogic = 1'b0;
  input  wciS0_Clk;
  input  wciS0_MReset_n;

  // action method wciS0_mCmd
  input  [2 : 0] wciS0_MCmd;

  // action method wciS0_mAddrSpace
  input  wciS0_MAddrSpace;

  // action method wciS0_mByteEn
  input  [3 : 0] wciS0_MByteEn;

  // action method wciS0_mAddr
  input  [31 : 0] wciS0_MAddr;

  // action method wciS0_mData
  input  [31 : 0] wciS0_MData;

  // value method wciS0_sResp
  output [1 : 0] wciS0_SResp;

  // value method wciS0_sData
  output [31 : 0] wciS0_SData;

  // value method wciS0_sThreadBusy
  output wciS0_SThreadBusy;

  // value method wciS0_sFlag
  output [2 : 0] wciS0_SFlag;

  // action method wciS0_mFlag
  input  [1 : 0] wciS0_MFlag;

  // signals for module outputs
  wire [31 : 0] wciS0_SData;
  wire [1 : 0] wciS0_SResp;
  wire [2 : 0] wciS0_SFlag;
  wire wciS0_SThreadBusy;

`else
`define NOT_EMPTY_icap
`include "icap-defs.vh"
`endif
  // inlined wires
  wire [71 : 0] wci_wslv_wciReq$wget;
  wire [33 : 0] wci_wslv_respF_x_wire$wget;
  wire [31 : 0] coutF_wDataIn$wget,
		coutF_wDataOut$wget,
		icap_icapIn_1$wget,
		icap_icapOut_1$wget,
		wci_wci_Es_mAddr_w$wget,
		wci_wci_Es_mData_w$wget;
  wire [10 : 0] coutF_rRdPtr_wdCounterCrossing$wget,
		coutF_rWrPtr_wdCounterCrossing$wget;
  wire [3 : 0] wci_wci_Es_mByteEn_w$wget;
  wire [2 : 0] wci_wci_Es_mCmd_w$wget, wci_wslv_wEdge$wget;
  wire cinF_dClear_pw$whas,
       cinF_deq_happened$whas,
       cinF_deq_pw$whas,
       cinF_enq_pw$whas,
       cinF_sClear_pw$whas,
       coutF_pwDequeue$whas,
       coutF_pwEnqueue$whas,
       coutF_rRdPtr_pwDecrement$whas,
       coutF_rRdPtr_pwIncrement$whas,
       coutF_rWrPtr_pwDecrement$whas,
       coutF_rWrPtr_pwIncrement$whas,
       coutF_wDataIn$whas,
       coutF_wDataOut$whas,
       icap_cre$wget,
       icap_cre$whas,
       icap_cwe$wget,
       icap_cwe$whas,
       icap_icapBusy_1$wget,
       icap_icapBusy_1$whas,
       icap_icapCs_1$wget,
       icap_icapCs_1$whas,
       icap_icapIn_1$whas,
       icap_icapOut_1$whas,
       icap_icapRd_1$wget,
       icap_icapRd_1$whas,
       wci_wci_Es_mAddrSpace_w$wget,
       wci_wci_Es_mAddrSpace_w$whas,
       wci_wci_Es_mAddr_w$whas,
       wci_wci_Es_mByteEn_w$whas,
       wci_wci_Es_mCmd_w$whas,
       wci_wci_Es_mData_w$whas,
       wci_wslv_ctlAckReg_1$wget,
       wci_wslv_ctlAckReg_1$whas,
       wci_wslv_reqF_r_clr$whas,
       wci_wslv_reqF_r_deq$whas,
       wci_wslv_reqF_r_enq$whas,
       wci_wslv_respF_dequeueing$whas,
       wci_wslv_respF_enqueueing$whas,
       wci_wslv_respF_x_wire$whas,
       wci_wslv_sFlagReg_1$wget,
       wci_wslv_sFlagReg_1$whas,
       wci_wslv_sThreadBusy_pw$whas,
       wci_wslv_wEdge$whas,
       wci_wslv_wciReq$whas,
       wci_wslv_wci_cfrd_pw$whas,
       wci_wslv_wci_cfwr_pw$whas,
       wci_wslv_wci_ctrl_pw$whas;

  // register cinF_head_wrapped
  reg cinF_head_wrapped;
  wire cinF_head_wrapped$D_IN, cinF_head_wrapped$EN;

  // register cinF_tail_wrapped
  reg cinF_tail_wrapped;
  wire cinF_tail_wrapped$D_IN, cinF_tail_wrapped$EN;

  // register cinS
  reg [31 : 0] cinS;
  wire [31 : 0] cinS$D_IN;
  wire cinS$EN;

  // register coutF_rRdPtr_rdCounter
  reg [10 : 0] coutF_rRdPtr_rdCounter;
  wire [10 : 0] coutF_rRdPtr_rdCounter$D_IN;
  wire coutF_rRdPtr_rdCounter$EN;

  // register coutF_rRdPtr_rdCounterPre
  reg [10 : 0] coutF_rRdPtr_rdCounterPre;
  wire [10 : 0] coutF_rRdPtr_rdCounterPre$D_IN;
  wire coutF_rRdPtr_rdCounterPre$EN;

  // register coutF_rRdPtr_rsCounter
  reg [10 : 0] coutF_rRdPtr_rsCounter;
  wire [10 : 0] coutF_rRdPtr_rsCounter$D_IN;
  wire coutF_rRdPtr_rsCounter$EN;

  // register coutF_rWrPtr_rdCounter
  reg [10 : 0] coutF_rWrPtr_rdCounter;
  wire [10 : 0] coutF_rWrPtr_rdCounter$D_IN;
  wire coutF_rWrPtr_rdCounter$EN;

  // register coutF_rWrPtr_rdCounterPre
  reg [10 : 0] coutF_rWrPtr_rdCounterPre;
  wire [10 : 0] coutF_rWrPtr_rdCounterPre$D_IN;
  wire coutF_rWrPtr_rdCounterPre$EN;

  // register coutF_rWrPtr_rsCounter
  reg [10 : 0] coutF_rWrPtr_rsCounter;
  wire [10 : 0] coutF_rWrPtr_rsCounter$D_IN;
  wire coutF_rWrPtr_rsCounter$EN;

  // register dwRead
  reg [31 : 0] dwRead;
  wire [31 : 0] dwRead$D_IN;
  wire dwRead$EN;

  // register dwWritten
  reg [31 : 0] dwWritten;
  wire [31 : 0] dwWritten$D_IN;
  wire dwWritten$EN;

  // register icapCtrl
  reg [31 : 0] icapCtrl;
  wire [31 : 0] icapCtrl$D_IN;
  wire icapCtrl$EN;

  // register icap_icapBusy
  reg icap_icapBusy;
  wire icap_icapBusy$D_IN, icap_icapBusy$EN;

  // register icap_icapCs
  reg icap_icapCs;
  wire icap_icapCs$D_IN, icap_icapCs$EN;

  // register icap_icapIn
  reg [31 : 0] icap_icapIn;
  wire [31 : 0] icap_icapIn$D_IN;
  wire icap_icapIn$EN;

  // register icap_icapOut
  reg [31 : 0] icap_icapOut;
  wire [31 : 0] icap_icapOut$D_IN;
  wire icap_icapOut$EN;

  // register icap_icapRd
  reg icap_icapRd;
  wire icap_icapRd$D_IN, icap_icapRd$EN;

  // register icap_inCount
  reg [31 : 0] icap_inCount;
  wire [31 : 0] icap_inCount$D_IN;
  wire icap_inCount$EN;

  // register icap_outCount
  reg [31 : 0] icap_outCount;
  wire [31 : 0] icap_outCount$D_IN;
  wire icap_outCount$EN;

  // register wci_wslv_cEdge
  reg [2 : 0] wci_wslv_cEdge;
  wire [2 : 0] wci_wslv_cEdge$D_IN;
  wire wci_wslv_cEdge$EN;

  // register wci_wslv_cState
  reg [2 : 0] wci_wslv_cState;
  wire [2 : 0] wci_wslv_cState$D_IN;
  wire wci_wslv_cState$EN;

  // register wci_wslv_ctlAckReg
  reg wci_wslv_ctlAckReg;
  wire wci_wslv_ctlAckReg$D_IN, wci_wslv_ctlAckReg$EN;

  // register wci_wslv_ctlOpActive
  reg wci_wslv_ctlOpActive;
  wire wci_wslv_ctlOpActive$D_IN, wci_wslv_ctlOpActive$EN;

  // register wci_wslv_illegalEdge
  reg wci_wslv_illegalEdge;
  wire wci_wslv_illegalEdge$D_IN, wci_wslv_illegalEdge$EN;

  // register wci_wslv_isReset_isInReset
  reg wci_wslv_isReset_isInReset;
  wire wci_wslv_isReset_isInReset$D_IN, wci_wslv_isReset_isInReset$EN;

  // register wci_wslv_nState
  reg [2 : 0] wci_wslv_nState;
  reg [2 : 0] wci_wslv_nState$D_IN;
  wire wci_wslv_nState$EN;

  // register wci_wslv_reqF_countReg
  reg [1 : 0] wci_wslv_reqF_countReg;
  wire [1 : 0] wci_wslv_reqF_countReg$D_IN;
  wire wci_wslv_reqF_countReg$EN;

  // register wci_wslv_respF_c_r
  reg [1 : 0] wci_wslv_respF_c_r;
  wire [1 : 0] wci_wslv_respF_c_r$D_IN;
  wire wci_wslv_respF_c_r$EN;

  // register wci_wslv_respF_q_0
  reg [33 : 0] wci_wslv_respF_q_0;
  reg [33 : 0] wci_wslv_respF_q_0$D_IN;
  wire wci_wslv_respF_q_0$EN;

  // register wci_wslv_respF_q_1
  reg [33 : 0] wci_wslv_respF_q_1;
  reg [33 : 0] wci_wslv_respF_q_1$D_IN;
  wire wci_wslv_respF_q_1$EN;

  // register wci_wslv_sFlagReg
  reg wci_wslv_sFlagReg;
  wire wci_wslv_sFlagReg$D_IN, wci_wslv_sFlagReg$EN;

  // register wci_wslv_sThreadBusy_d
  reg wci_wslv_sThreadBusy_d;
  wire wci_wslv_sThreadBusy_d$D_IN, wci_wslv_sThreadBusy_d$EN;

  // ports of submodule cd
  wire cd$CLK_OUT, cd$PREEDGE;

  // ports of submodule cinF_dCombinedReset
  wire cinF_dCombinedReset$RST_OUT;

  // ports of submodule cinF_dCrossedsReset
  wire cinF_dCrossedsReset$OUT_RST;

  // ports of submodule cinF_dInReset
  wire cinF_dInReset$VAL;

  // ports of submodule cinF_sCombinedReset
  wire cinF_sCombinedReset$RST_OUT;

  // ports of submodule cinF_sCrosseddReset
  wire cinF_sCrosseddReset$OUT_RST;

  // ports of submodule cinF_sInReset
  wire cinF_sInReset$VAL;

  // ports of submodule coutF_memory
  wire [31 : 0] coutF_memory$DIA, coutF_memory$DIB, coutF_memory$DOB;
  wire [9 : 0] coutF_memory$ADDRA, coutF_memory$ADDRB;
  wire coutF_memory$ENA, coutF_memory$ENB, coutF_memory$WEA, coutF_memory$WEB;

  // ports of submodule cre
  wire cre$dD_OUT, cre$sD_IN, cre$sEN, cre$sRDY;

  // ports of submodule cwe
  wire cwe$dD_OUT, cwe$sD_IN, cwe$sEN, cwe$sRDY;

  // ports of submodule icap_cinF
  wire [31 : 0] icap_cinF$D_IN, icap_cinF$D_OUT;
  wire icap_cinF$CLR,
       icap_cinF$DEQ,
       icap_cinF$EMPTY_N,
       icap_cinF$ENQ,
       icap_cinF$FULL_N;

  // ports of submodule icap_coutF
  wire [31 : 0] icap_coutF$D_IN, icap_coutF$D_OUT;
  wire icap_coutF$CLR,
       icap_coutF$DEQ,
       icap_coutF$EMPTY_N,
       icap_coutF$ENQ,
       icap_coutF$FULL_N;

  // ports of submodule icap_icap
  wire [31 : 0] icap_icap$I, icap_icap$O;
  wire icap_icap$BUSY, icap_icap$CSB, icap_icap$RDWRB;

  // ports of submodule inCnt
  wire [31 : 0] inCnt$dD_OUT, inCnt$sD_IN;
  wire inCnt$sEN, inCnt$sRDY;

  // ports of submodule outCnt
  wire [31 : 0] outCnt$dD_OUT, outCnt$sD_IN;
  wire outCnt$sEN, outCnt$sRDY;

  // ports of submodule slowReset
  wire slowReset$OUT_RST;

  // ports of submodule wci_wslv_reqF
  wire [71 : 0] wci_wslv_reqF$D_IN, wci_wslv_reqF$D_OUT;
  wire wci_wslv_reqF$CLR,
       wci_wslv_reqF$DEQ,
       wci_wslv_reqF$EMPTY_N,
       wci_wslv_reqF$ENQ;

  // rule scheduling signals
  wire CAN_FIRE_RL_wci_cfrd,
       WILL_FIRE_RL_cinF_deq_update_head,
       WILL_FIRE_RL_cinF_enq_update_tail,
       WILL_FIRE_RL_icap_read_configuration_data,
       WILL_FIRE_RL_icap_write_configration_data,
       WILL_FIRE_RL_wci_cfrd,
       WILL_FIRE_RL_wci_cfwr,
       WILL_FIRE_RL_wci_ctrl_EiI,
       WILL_FIRE_RL_wci_ctrl_IsO,
       WILL_FIRE_RL_wci_ctrl_OrE,
       WILL_FIRE_RL_wci_wslv_ctl_op_complete,
       WILL_FIRE_RL_wci_wslv_ctl_op_start,
       WILL_FIRE_RL_wci_wslv_respF_both,
       WILL_FIRE_RL_wci_wslv_respF_decCtr,
       WILL_FIRE_RL_wci_wslv_respF_incCtr;

  // inputs to muxes for submodule ports
  reg [33 : 0] MUX_wci_wslv_respF_q_0$write_1__VAL_2;
  wire [33 : 0] MUX_wci_wslv_respF_q_0$write_1__VAL_1,
		MUX_wci_wslv_respF_q_1$write_1__VAL_1,
		MUX_wci_wslv_respF_x_wire$wset_1__VAL_1,
		MUX_wci_wslv_respF_x_wire$wset_1__VAL_2;
  wire [10 : 0] MUX_coutF_rRdPtr_rsCounter$write_1__VAL_1,
		MUX_coutF_rWrPtr_rsCounter$write_1__VAL_1;
  wire [1 : 0] MUX_wci_wslv_respF_c_r$write_1__VAL_1,
	       MUX_wci_wslv_respF_c_r$write_1__VAL_2;
  wire MUX_wci_wslv_illegalEdge$write_1__SEL_1,
       MUX_wci_wslv_illegalEdge$write_1__VAL_1,
       MUX_wci_wslv_respF_q_0$write_1__SEL_2,
       MUX_wci_wslv_respF_q_1$write_1__SEL_2;

  // remaining internal signals
  reg [63 : 0] v__h26767, v__h3695, v__h3870, v__h4014;
  reg [31 : 0] v__h26514;
  wire [31 : 0] IF_coutF_rRdPtr_rsCounter_93_BIT_0_00_OR_coutF_ETC___d756,
		IF_coutF_rWrPtr_rsCounter_24_BIT_0_31_OR_coutF_ETC___d755,
		IF_coutF_rWrPtr_rsCounter_24_BIT_0_31_XOR_cout_ETC___d754,
		icapStatus__h26137,
		rdat__h26538,
		rdat__h26544,
		rdat__h26550,
		rdat__h26556,
		x3__h20817,
		x__h19564;
  wire [10 : 0] coutF_rRdPtr_rdCounter_24_BIT_10_25_CONCAT_cou_ETC___d675,
		x__h16406,
		x__h18708,
		x__h22081,
		x_dReadBin__h20521,
		x_sReadBin__h20518,
		y__h17293,
		y__h19595;
  wire [9 : 0] x2__h22050;
  wire [2 : 0] x__h26631;
  wire NOT_coutF_rRdPtr_rsCounter_93_EQ_coutF_rWrPtr__ETC___d601,
       NOT_wci_wslv_respF_c_r_2_EQ_2_1_2_AND_wci_wslv_ETC___d592,
       coutF_rRdPtr_rdCounter_24_BIT_10_25_XOR_coutF__ETC___d669,
       coutF_rRdPtr_rdCounter_24_BIT_10_25_XOR_coutF__ETC___d670,
       coutF_rRdPtr_rdCounter_24_BIT_10_25_XOR_coutF__ETC___d671,
       coutF_rRdPtr_rdCounter_24_BIT_10_25_XOR_coutF__ETC___d672,
       coutF_rRdPtr_rdCounter_24_BIT_10_25_XOR_coutF__ETC___d673,
       coutF_rRdPtr_rdCounter_24_BIT_10_25_XOR_coutF__ETC___d674,
       coutF_rRdPtr_rdCounter_24_BIT_10_25_XOR_coutF__ETC___d676,
       coutF_rRdPtr_rdCounter_24_BIT_10_25_XOR_coutF__ETC___d678,
       coutF_rRdPtr_rdCounter_24_BIT_10_25_XOR_coutF__ETC___d683,
       coutF_rRdPtr_rsCounter_93_BIT_0_00_XOR_coutF_r_ETC___d722,
       coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d662,
       coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d663,
       coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d664,
       coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d665,
       coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d666,
       coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d667,
       coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d668,
       coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d680,
       coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d682,
       coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d701,
       coutF_rWrPtr_rsCounter_24_BIT_0_31_XOR_coutF_r_ETC___d721,
       coutF_rWrPtr_rsCounter_24_BIT_10_50_XOR_coutF__ETC___d654,
       coutF_rWrPtr_rsCounter_24_BIT_10_50_XOR_coutF__ETC___d655,
       coutF_rWrPtr_rsCounter_24_BIT_10_50_XOR_coutF__ETC___d656,
       coutF_rWrPtr_rsCounter_24_BIT_10_50_XOR_coutF__ETC___d657,
       coutF_rWrPtr_rsCounter_24_BIT_10_50_XOR_coutF__ETC___d658,
       coutF_rWrPtr_rsCounter_24_BIT_10_50_XOR_coutF__ETC___d659,
       coutF_rWrPtr_rsCounter_24_BIT_10_50_XOR_coutF__ETC___d660,
       coutF_rWrPtr_rsCounter_24_BIT_10_50_XOR_coutF__ETC___d661,
       coutF_rWrPtr_rsCounter_24_BIT_10_50_XOR_coutF__ETC___d681,
       z__h17337,
       z__h17344,
       z__h17351,
       z__h17358,
       z__h17365,
       z__h17372,
       z__h17379,
       z__h17386,
       z__h17393,
       z__h19639,
       z__h19646,
       z__h19653,
       z__h19660,
       z__h19667,
       z__h19674,
       z__h19681,
       z__h19688,
       z__h19695;

  // value method wciS0_sResp
  assign wciS0_SResp = wci_wslv_respF_q_0[33:32] ;

  // value method wciS0_sData
  assign wciS0_SData = wci_wslv_respF_q_0[31:0] ;

  // value method wciS0_sThreadBusy
  assign wciS0_SThreadBusy =
	     wci_wslv_reqF_countReg > 2'd1 || wci_wslv_isReset_isInReset ;

  // value method wciS0_sFlag
  assign wciS0_SFlag = { 1'd0, 1'd1, wci_wslv_sFlagReg } ;

  // submodule cd
  ClockDiv #(.width(32'd1),
	     .lower(32'd0),
	     .upper(32'd1),
	     .offset(32'd0)) cd(.CLK_IN(wciS0_Clk),
				.RST(wciS0_MReset_n),
				.PREEDGE(cd$PREEDGE),
				.CLK_OUT(cd$CLK_OUT));

  // submodule cinF_dCombinedReset
  ResetEither cinF_dCombinedReset(.A_RST(slowReset$OUT_RST),
				  .B_RST(cinF_dCrossedsReset$OUT_RST),
				  .RST_OUT(cinF_dCombinedReset$RST_OUT));

  // submodule cinF_dCrossedsReset
  SyncReset0 cinF_dCrossedsReset(.IN_RST(wciS0_MReset_n),
				 .OUT_RST(cinF_dCrossedsReset$OUT_RST));

  // submodule cinF_dInReset
  ResetToBool cinF_dInReset(.RST(cinF_dCombinedReset$RST_OUT),
			    .VAL(cinF_dInReset$VAL));

  // submodule cinF_sCombinedReset
  ResetEither cinF_sCombinedReset(.A_RST(wciS0_MReset_n),
				  .B_RST(cinF_sCrosseddReset$OUT_RST),
				  .RST_OUT(cinF_sCombinedReset$RST_OUT));

  // submodule cinF_sCrosseddReset
  SyncReset0 cinF_sCrosseddReset(.IN_RST(slowReset$OUT_RST),
				 .OUT_RST(cinF_sCrosseddReset$OUT_RST));

  // submodule cinF_sInReset
  ResetToBool cinF_sInReset(.RST(cinF_sCombinedReset$RST_OUT),
			    .VAL(cinF_sInReset$VAL));

  // submodule coutF_memory
  BRAM2 #(.PIPELINED(1'd0),
	  .ADDR_WIDTH(32'd10),
	  .DATA_WIDTH(32'd32),
	  .MEMSIZE(11'd1024)) coutF_memory(.CLKA(cd$CLK_OUT),
					   .CLKB(wciS0_Clk),
					   .ADDRA(coutF_memory$ADDRA),
					   .ADDRB(coutF_memory$ADDRB),
					   .DIA(coutF_memory$DIA),
					   .DIB(coutF_memory$DIB),
					   .WEA(coutF_memory$WEA),
					   .WEB(coutF_memory$WEB),
					   .ENA(coutF_memory$ENA),
					   .ENB(coutF_memory$ENB),
					   .DOA(),
					   .DOB(coutF_memory$DOB));

  // submodule cre
  SyncRegister #(.width(32'd1), .init(1'd0)) cre(.sCLK(wciS0_Clk),
						 .dCLK(cd$CLK_OUT),
						 .sRST(wciS0_MReset_n),
						 .sD_IN(cre$sD_IN),
						 .sEN(cre$sEN),
						 .dD_OUT(cre$dD_OUT),
						 .sRDY(cre$sRDY));

  // submodule cwe
  SyncRegister #(.width(32'd1), .init(1'd0)) cwe(.sCLK(wciS0_Clk),
						 .dCLK(cd$CLK_OUT),
						 .sRST(wciS0_MReset_n),
						 .sD_IN(cwe$sD_IN),
						 .sEN(cwe$sEN),
						 .dD_OUT(cwe$dD_OUT),
						 .sRDY(cwe$sRDY));

  // submodule icap_cinF
  FIFO2 #(.width(32'd32), .guarded(32'd1)) icap_cinF(.RST(slowReset$OUT_RST),
						     .CLK(cd$CLK_OUT),
						     .D_IN(icap_cinF$D_IN),
						     .ENQ(icap_cinF$ENQ),
						     .DEQ(icap_cinF$DEQ),
						     .CLR(icap_cinF$CLR),
						     .D_OUT(icap_cinF$D_OUT),
						     .FULL_N(icap_cinF$FULL_N),
						     .EMPTY_N(icap_cinF$EMPTY_N));

  // submodule icap_coutF
  FIFO2 #(.width(32'd32), .guarded(32'd1)) icap_coutF(.RST(slowReset$OUT_RST),
						      .CLK(cd$CLK_OUT),
						      .D_IN(icap_coutF$D_IN),
						      .ENQ(icap_coutF$ENQ),
						      .DEQ(icap_coutF$DEQ),
						      .CLR(icap_coutF$CLR),
						      .D_OUT(icap_coutF$D_OUT),
						      .FULL_N(icap_coutF$FULL_N),
						      .EMPTY_N(icap_coutF$EMPTY_N));

  // submodule icap_icap
  ICAP_VIRTEX6 #(.ICAP_WIDTH("X32")) icap_icap(.CLK(cd$CLK_OUT),
					       .CSB(icap_icap$CSB),
					       .I(icap_icap$I),
					       .RDWRB(icap_icap$RDWRB),
					       .O(icap_icap$O),
					       .BUSY(icap_icap$BUSY));

  // submodule inCnt
  SyncRegister #(.width(32'd32), .init(32'd0)) inCnt(.sCLK(cd$CLK_OUT),
						     .dCLK(wciS0_Clk),
						     .sRST(slowReset$OUT_RST),
						     .sD_IN(inCnt$sD_IN),
						     .sEN(inCnt$sEN),
						     .dD_OUT(inCnt$dD_OUT),
						     .sRDY(inCnt$sRDY));

  // submodule outCnt
  SyncRegister #(.width(32'd32), .init(32'd0)) outCnt(.sCLK(cd$CLK_OUT),
						      .dCLK(wciS0_Clk),
						      .sRST(slowReset$OUT_RST),
						      .sD_IN(outCnt$sD_IN),
						      .sEN(outCnt$sEN),
						      .dD_OUT(outCnt$dD_OUT),
						      .sRDY(outCnt$sRDY));

  // submodule slowReset
  SyncResetA #(.RSTDELAY(32'd1)) slowReset(.CLK(cd$CLK_OUT),
					   .IN_RST(wciS0_MReset_n),
					   .OUT_RST(slowReset$OUT_RST));

  // submodule wci_wslv_reqF
  SizedFIFO #(.p1width(32'd72),
	      .p2depth(32'd3),
	      .p3cntr_width(32'd1),
	      .guarded(32'd1)) wci_wslv_reqF(.RST(wciS0_MReset_n),
					     .CLK(wciS0_Clk),
					     .D_IN(wci_wslv_reqF$D_IN),
					     .ENQ(wci_wslv_reqF$ENQ),
					     .DEQ(wci_wslv_reqF$DEQ),
					     .CLR(wci_wslv_reqF$CLR),
					     .D_OUT(wci_wslv_reqF$D_OUT),
					     .FULL_N(),
					     .EMPTY_N(wci_wslv_reqF$EMPTY_N));

  // rule RL_wci_cfwr
  assign WILL_FIRE_RL_wci_cfwr =
	     NOT_wci_wslv_respF_c_r_2_EQ_2_1_2_AND_wci_wslv_ETC___d592 &&
	     wci_wslv_wci_cfwr_pw$whas &&
	     !WILL_FIRE_RL_wci_wslv_ctl_op_start &&
	     !WILL_FIRE_RL_wci_wslv_ctl_op_complete ;

  // rule RL_wci_wslv_ctl_op_start
  assign WILL_FIRE_RL_wci_wslv_ctl_op_start =
	     wci_wslv_reqF$EMPTY_N && wci_wslv_wci_ctrl_pw$whas &&
	     !WILL_FIRE_RL_wci_wslv_ctl_op_complete ;

  // rule RL_wci_ctrl_IsO
  assign WILL_FIRE_RL_wci_ctrl_IsO =
	     wci_wslv_wci_ctrl_pw$whas &&
	     WILL_FIRE_RL_wci_wslv_ctl_op_start &&
	     wci_wslv_cState == 3'd1 &&
	     wci_wslv_reqF$D_OUT[36:34] == 3'd1 ;

  // rule RL_wci_ctrl_EiI
  assign WILL_FIRE_RL_wci_ctrl_EiI =
	     wci_wslv_wci_ctrl_pw$whas &&
	     WILL_FIRE_RL_wci_wslv_ctl_op_start &&
	     wci_wslv_cState == 3'd0 &&
	     wci_wslv_reqF$D_OUT[36:34] == 3'd0 ;

  // rule RL_wci_ctrl_OrE
  assign WILL_FIRE_RL_wci_ctrl_OrE =
	     wci_wslv_wci_ctrl_pw$whas &&
	     WILL_FIRE_RL_wci_wslv_ctl_op_start &&
	     wci_wslv_cState == 3'd2 &&
	     wci_wslv_reqF$D_OUT[36:34] == 3'd3 ;

  // rule RL_wci_wslv_ctl_op_complete
  assign WILL_FIRE_RL_wci_wslv_ctl_op_complete =
	     wci_wslv_respF_c_r != 2'd2 && wci_wslv_ctlOpActive &&
	     wci_wslv_ctlAckReg ;

  // rule RL_icap_write_configration_data
  assign WILL_FIRE_RL_icap_write_configration_data =
	     icap_cinF$EMPTY_N && cwe$dD_OUT && !cre$dD_OUT ;

  // rule RL_icap_read_configuration_data
  assign WILL_FIRE_RL_icap_read_configuration_data =
	     (icap_icapBusy || icap_coutF$FULL_N) && cre$dD_OUT &&
	     !cwe$dD_OUT ;

  // rule RL_cinF_enq_update_tail
  assign WILL_FIRE_RL_cinF_enq_update_tail =
	     !cinF_sInReset$VAL && cinF_enq_pw$whas ;

  // rule RL_cinF_deq_update_head
  assign WILL_FIRE_RL_cinF_deq_update_head =
	     !cinF_dInReset$VAL && cinF_deq_pw$whas ;

  // rule RL_wci_cfrd
  assign CAN_FIRE_RL_wci_cfrd =
	     wci_wslv_respF_c_r != 2'd2 && wci_wslv_reqF$EMPTY_N &&
	     (wci_wslv_reqF$D_OUT[63:32] != 32'h0000000C ||
	      NOT_coutF_rRdPtr_rsCounter_93_EQ_coutF_rWrPtr__ETC___d601) &&
	     wci_wslv_wci_cfrd_pw$whas ;
  assign WILL_FIRE_RL_wci_cfrd =
	     CAN_FIRE_RL_wci_cfrd && !WILL_FIRE_RL_wci_wslv_ctl_op_start &&
	     !WILL_FIRE_RL_wci_wslv_ctl_op_complete ;

  // rule RL_wci_wslv_respF_incCtr
  assign WILL_FIRE_RL_wci_wslv_respF_incCtr =
	     ((wci_wslv_respF_c_r == 2'd0) ?
		wci_wslv_respF_x_wire$whas :
		wci_wslv_respF_c_r != 2'd1 || wci_wslv_respF_x_wire$whas) &&
	     wci_wslv_respF_enqueueing$whas &&
	     !(wci_wslv_respF_c_r != 2'd0) ;

  // rule RL_wci_wslv_respF_decCtr
  assign WILL_FIRE_RL_wci_wslv_respF_decCtr =
	     wci_wslv_respF_c_r != 2'd0 && !wci_wslv_respF_enqueueing$whas ;

  // rule RL_wci_wslv_respF_both
  assign WILL_FIRE_RL_wci_wslv_respF_both =
	     ((wci_wslv_respF_c_r == 2'd1) ?
		wci_wslv_respF_x_wire$whas :
		wci_wslv_respF_c_r != 2'd2 || wci_wslv_respF_x_wire$whas) &&
	     wci_wslv_respF_c_r != 2'd0 &&
	     wci_wslv_respF_enqueueing$whas ;

  // inputs to muxes for submodule ports
  assign MUX_wci_wslv_illegalEdge$write_1__SEL_1 =
	     WILL_FIRE_RL_wci_wslv_ctl_op_start &&
	     (wci_wslv_reqF$D_OUT[36:34] == 3'd0 && wci_wslv_cState != 3'd0 ||
	      wci_wslv_reqF$D_OUT[36:34] == 3'd1 && wci_wslv_cState != 3'd1 &&
	      wci_wslv_cState != 3'd3 ||
	      wci_wslv_reqF$D_OUT[36:34] == 3'd2 && wci_wslv_cState != 3'd2 ||
	      wci_wslv_reqF$D_OUT[36:34] == 3'd3 && wci_wslv_cState != 3'd3 &&
	      wci_wslv_cState != 3'd2 &&
	      wci_wslv_cState != 3'd1 ||
	      wci_wslv_reqF$D_OUT[36:34] == 3'd4 ||
	      wci_wslv_reqF$D_OUT[36:34] == 3'd5 ||
	      wci_wslv_reqF$D_OUT[36:34] == 3'd6 ||
	      wci_wslv_reqF$D_OUT[36:34] == 3'd7) ;
  assign MUX_wci_wslv_respF_q_0$write_1__SEL_2 =
	     WILL_FIRE_RL_wci_wslv_respF_incCtr &&
	     wci_wslv_respF_c_r == 2'd0 ;
  assign MUX_wci_wslv_respF_q_1$write_1__SEL_2 =
	     WILL_FIRE_RL_wci_wslv_respF_incCtr &&
	     wci_wslv_respF_c_r == 2'd1 ;
  assign MUX_coutF_rRdPtr_rsCounter$write_1__VAL_1 =
	     (~coutF_rRdPtr_rsCounter[x__h19564[3:0]]) ?
	       coutF_rRdPtr_rsCounter | x__h18708 :
	       coutF_rRdPtr_rsCounter & y__h19595 ;
  assign MUX_coutF_rWrPtr_rsCounter$write_1__VAL_1 =
	     (~coutF_rWrPtr_rsCounter[IF_coutF_rWrPtr_rsCounter_24_BIT_0_31_XOR_cout_ETC___d754[3:0]]) ?
	       coutF_rWrPtr_rsCounter | x__h16406 :
	       coutF_rWrPtr_rsCounter & y__h17293 ;
  assign MUX_wci_wslv_illegalEdge$write_1__VAL_1 =
	     wci_wslv_reqF$D_OUT[36:34] != 3'd4 &&
	     wci_wslv_reqF$D_OUT[36:34] != 3'd5 &&
	     wci_wslv_reqF$D_OUT[36:34] != 3'd6 ;
  assign MUX_wci_wslv_respF_c_r$write_1__VAL_1 = wci_wslv_respF_c_r + 2'd1 ;
  assign MUX_wci_wslv_respF_c_r$write_1__VAL_2 = wci_wslv_respF_c_r - 2'd1 ;
  assign MUX_wci_wslv_respF_q_0$write_1__VAL_1 =
	     (wci_wslv_respF_c_r == 2'd1) ?
	       MUX_wci_wslv_respF_q_0$write_1__VAL_2 :
	       wci_wslv_respF_q_1 ;
  always@(WILL_FIRE_RL_wci_wslv_ctl_op_complete or
	  MUX_wci_wslv_respF_x_wire$wset_1__VAL_1 or
	  WILL_FIRE_RL_wci_cfrd or
	  MUX_wci_wslv_respF_x_wire$wset_1__VAL_2 or WILL_FIRE_RL_wci_cfwr)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_wci_wslv_ctl_op_complete:
	  MUX_wci_wslv_respF_q_0$write_1__VAL_2 =
	      MUX_wci_wslv_respF_x_wire$wset_1__VAL_1;
      WILL_FIRE_RL_wci_cfrd:
	  MUX_wci_wslv_respF_q_0$write_1__VAL_2 =
	      MUX_wci_wslv_respF_x_wire$wset_1__VAL_2;
      WILL_FIRE_RL_wci_cfwr:
	  MUX_wci_wslv_respF_q_0$write_1__VAL_2 = 34'h1C0DE4201;
      default: MUX_wci_wslv_respF_q_0$write_1__VAL_2 =
		   34'h2AAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign MUX_wci_wslv_respF_q_1$write_1__VAL_1 =
	     (wci_wslv_respF_c_r == 2'd2) ?
	       MUX_wci_wslv_respF_q_0$write_1__VAL_2 :
	       34'h0AAAAAAAA ;
  assign MUX_wci_wslv_respF_x_wire$wset_1__VAL_1 =
	     wci_wslv_illegalEdge ? 34'h3C0DE4202 : 34'h1C0DE4201 ;
  assign MUX_wci_wslv_respF_x_wire$wset_1__VAL_2 = { 2'd1, v__h26514 } ;

  // inlined wires
  assign wci_wslv_wciReq$wget =
	     { wciS0_MCmd,
	       wciS0_MAddrSpace,
	       wciS0_MByteEn,
	       wciS0_MAddr,
	       wciS0_MData } ;
  assign wci_wslv_wciReq$whas = 1'd1 ;
  assign wci_wslv_respF_x_wire$wget = MUX_wci_wslv_respF_q_0$write_1__VAL_2 ;
  assign wci_wslv_respF_x_wire$whas =
	     WILL_FIRE_RL_wci_wslv_ctl_op_complete || WILL_FIRE_RL_wci_cfrd ||
	     WILL_FIRE_RL_wci_cfwr ;
  assign wci_wslv_wEdge$wget = wci_wslv_reqF$D_OUT[36:34] ;
  assign wci_wslv_wEdge$whas = WILL_FIRE_RL_wci_wslv_ctl_op_start ;
  assign wci_wslv_sFlagReg_1$wget = 1'b0 ;
  assign wci_wslv_sFlagReg_1$whas = 1'b0 ;
  assign wci_wslv_ctlAckReg_1$wget = 1'd1 ;
  assign wci_wslv_ctlAckReg_1$whas =
	     WILL_FIRE_RL_wci_ctrl_OrE || WILL_FIRE_RL_wci_ctrl_IsO ||
	     WILL_FIRE_RL_wci_ctrl_EiI ;
  assign wci_wci_Es_mCmd_w$wget = wciS0_MCmd ;
  assign wci_wci_Es_mCmd_w$whas = 1'd1 ;
  assign wci_wci_Es_mAddrSpace_w$wget = wciS0_MAddrSpace ;
  assign wci_wci_Es_mAddrSpace_w$whas = 1'd1 ;
  assign wci_wci_Es_mByteEn_w$wget = wciS0_MByteEn ;
  assign wci_wci_Es_mByteEn_w$whas = 1'd1 ;
  assign wci_wci_Es_mAddr_w$wget = wciS0_MAddr ;
  assign wci_wci_Es_mAddr_w$whas = 1'd1 ;
  assign wci_wci_Es_mData_w$wget = wciS0_MData ;
  assign wci_wci_Es_mData_w$whas = 1'd1 ;
  assign icap_icapCs_1$wget = 1'd1 ;
  assign icap_icapCs_1$whas =
	     WILL_FIRE_RL_icap_read_configuration_data ||
	     WILL_FIRE_RL_icap_write_configration_data ;
  assign icap_icapRd_1$wget = !WILL_FIRE_RL_icap_write_configration_data ;
  assign icap_icapRd_1$whas =
	     WILL_FIRE_RL_icap_write_configration_data ||
	     WILL_FIRE_RL_icap_read_configuration_data ;
  assign icap_icapIn_1$wget =
	     { icap_cinF$D_OUT[24],
	       icap_cinF$D_OUT[25],
	       icap_cinF$D_OUT[26],
	       icap_cinF$D_OUT[27],
	       icap_cinF$D_OUT[28],
	       icap_cinF$D_OUT[29],
	       icap_cinF$D_OUT[30],
	       icap_cinF$D_OUT[31],
	       icap_cinF$D_OUT[16],
	       icap_cinF$D_OUT[17],
	       icap_cinF$D_OUT[18],
	       icap_cinF$D_OUT[19],
	       icap_cinF$D_OUT[20],
	       icap_cinF$D_OUT[21],
	       icap_cinF$D_OUT[22],
	       icap_cinF$D_OUT[23],
	       icap_cinF$D_OUT[8],
	       icap_cinF$D_OUT[9],
	       icap_cinF$D_OUT[10],
	       icap_cinF$D_OUT[11],
	       icap_cinF$D_OUT[12],
	       icap_cinF$D_OUT[13],
	       icap_cinF$D_OUT[14],
	       icap_cinF$D_OUT[15],
	       icap_cinF$D_OUT[0],
	       icap_cinF$D_OUT[1],
	       icap_cinF$D_OUT[2],
	       icap_cinF$D_OUT[3],
	       icap_cinF$D_OUT[4],
	       icap_cinF$D_OUT[5],
	       icap_cinF$D_OUT[6],
	       icap_cinF$D_OUT[7] } ;
  assign icap_icapIn_1$whas = WILL_FIRE_RL_icap_write_configration_data ;
  assign icap_icapOut_1$wget = icap_icap$O ;
  assign icap_icapOut_1$whas = 1'd1 ;
  assign icap_icapBusy_1$wget = icap_icap$BUSY ;
  assign icap_icapBusy_1$whas = 1'd1 ;
  assign icap_cwe$wget = cwe$dD_OUT ;
  assign icap_cwe$whas = 1'd1 ;
  assign icap_cre$wget = cre$dD_OUT ;
  assign icap_cre$whas = 1'd1 ;
  assign coutF_wDataIn$wget = icap_coutF$D_OUT ;
  assign coutF_wDataIn$whas = coutF_pwEnqueue$whas ;
  assign coutF_wDataOut$wget = coutF_memory$DOB ;
  assign coutF_wDataOut$whas = 1'd1 ;
  assign wci_wslv_reqF_r_enq$whas = wci_wslv_wciReq$wget[71:69] != 3'd0 ;
  assign wci_wslv_reqF_r_deq$whas =
	     WILL_FIRE_RL_wci_cfrd || WILL_FIRE_RL_wci_cfwr ||
	     WILL_FIRE_RL_wci_wslv_ctl_op_start ;
  assign wci_wslv_reqF_r_clr$whas = 1'b0 ;
  assign wci_wslv_respF_enqueueing$whas =
	     WILL_FIRE_RL_wci_cfrd || WILL_FIRE_RL_wci_cfwr ||
	     WILL_FIRE_RL_wci_wslv_ctl_op_complete ;
  assign wci_wslv_respF_dequeueing$whas = wci_wslv_respF_c_r != 2'd0 ;
  assign wci_wslv_sThreadBusy_pw$whas = 1'b0 ;
  assign wci_wslv_wci_cfwr_pw$whas =
	     wci_wslv_reqF$EMPTY_N && wci_wslv_reqF$D_OUT[68] &&
	     wci_wslv_reqF$D_OUT[71:69] == 3'd1 ;
  assign wci_wslv_wci_cfrd_pw$whas =
	     wci_wslv_reqF$EMPTY_N && wci_wslv_reqF$D_OUT[68] &&
	     wci_wslv_reqF$D_OUT[71:69] == 3'd2 ;
  assign wci_wslv_wci_ctrl_pw$whas =
	     wci_wslv_reqF$EMPTY_N && !wci_wslv_reqF$D_OUT[68] &&
	     wci_wslv_reqF$D_OUT[71:69] == 3'd2 ;
  assign cinF_enq_pw$whas =
	     WILL_FIRE_RL_wci_cfwr &&
	     wci_wslv_reqF$D_OUT[63:32] == 32'h00000008 ;
  assign cinF_deq_pw$whas =
	     cinF_head_wrapped != cinF_tail_wrapped && !cinF_dInReset$VAL &&
	     icap_cinF$FULL_N ;
  assign cinF_sClear_pw$whas = 1'b0 ;
  assign cinF_dClear_pw$whas = 1'b0 ;
  assign cinF_deq_happened$whas = 1'b0 ;
  assign coutF_rWrPtr_pwIncrement$whas = coutF_pwEnqueue$whas ;
  assign coutF_rWrPtr_pwDecrement$whas = 1'b0 ;
  assign coutF_rRdPtr_pwIncrement$whas = coutF_pwDequeue$whas ;
  assign coutF_rRdPtr_pwDecrement$whas = 1'b0 ;
  assign coutF_pwDequeue$whas =
	     WILL_FIRE_RL_wci_cfrd &&
	     wci_wslv_reqF$D_OUT[63:32] == 32'h0000000C ;
  assign coutF_pwEnqueue$whas =
	     coutF_rWrPtr_rsCounter !=
	     { coutF_rRdPtr_rdCounter_24_BIT_10_25_CONCAT_cou_ETC___d675[10],
	       coutF_rRdPtr_rdCounter_24_BIT_10_25_CONCAT_cou_ETC___d675[10] ^
	       coutF_rRdPtr_rdCounter_24_BIT_10_25_CONCAT_cou_ETC___d675[9],
	       coutF_rRdPtr_rdCounter_24_BIT_10_25_CONCAT_cou_ETC___d675[9] ^
	       coutF_rRdPtr_rdCounter_24_BIT_10_25_CONCAT_cou_ETC___d675[8],
	       coutF_rRdPtr_rdCounter_24_BIT_10_25_CONCAT_cou_ETC___d675[8] ^
	       coutF_rRdPtr_rdCounter_24_BIT_10_25_CONCAT_cou_ETC___d675[7],
	       coutF_rRdPtr_rdCounter_24_BIT_10_25_CONCAT_cou_ETC___d675[7] ^
	       coutF_rRdPtr_rdCounter_24_BIT_10_25_CONCAT_cou_ETC___d675[6],
	       coutF_rRdPtr_rdCounter_24_BIT_10_25_CONCAT_cou_ETC___d675[6] ^
	       coutF_rRdPtr_rdCounter_24_BIT_10_25_CONCAT_cou_ETC___d675[5],
	       coutF_rRdPtr_rdCounter_24_BIT_10_25_CONCAT_cou_ETC___d675[5] ^
	       coutF_rRdPtr_rdCounter_24_BIT_10_25_CONCAT_cou_ETC___d675[4],
	       coutF_rRdPtr_rdCounter_24_BIT_10_25_CONCAT_cou_ETC___d675[4] ^
	       coutF_rRdPtr_rdCounter_24_BIT_10_25_CONCAT_cou_ETC___d675[3],
	       coutF_rRdPtr_rdCounter_24_BIT_10_25_CONCAT_cou_ETC___d675[3] ^
	       coutF_rRdPtr_rdCounter_24_BIT_10_25_CONCAT_cou_ETC___d675[2],
	       coutF_rRdPtr_rdCounter_24_BIT_10_25_CONCAT_cou_ETC___d675[2] ^
	       coutF_rRdPtr_rdCounter_24_BIT_10_25_CONCAT_cou_ETC___d675[1],
	       coutF_rRdPtr_rdCounter_24_BIT_10_25_CONCAT_cou_ETC___d675[1] ^
	       coutF_rRdPtr_rdCounter_24_BIT_10_25_CONCAT_cou_ETC___d675[0] } &&
	     icap_coutF$EMPTY_N ;
  assign coutF_rWrPtr_wdCounterCrossing$wget = coutF_rWrPtr_rsCounter ;
  assign coutF_rRdPtr_wdCounterCrossing$wget = coutF_rRdPtr_rsCounter ;

  // register cinF_head_wrapped
  assign cinF_head_wrapped$D_IN =
	     WILL_FIRE_RL_cinF_deq_update_head && !cinF_head_wrapped ;
  assign cinF_head_wrapped$EN =
	     WILL_FIRE_RL_cinF_deq_update_head || cinF_dInReset$VAL ;

  // register cinF_tail_wrapped
  assign cinF_tail_wrapped$D_IN =
	     WILL_FIRE_RL_cinF_enq_update_tail && !cinF_tail_wrapped ;
  assign cinF_tail_wrapped$EN =
	     WILL_FIRE_RL_cinF_enq_update_tail || cinF_sInReset$VAL ;

  // register cinS
  assign cinS$D_IN = wci_wslv_reqF$D_OUT[31:0] ;
  assign cinS$EN = cinF_enq_pw$whas ;

  // register coutF_rRdPtr_rdCounter
  assign coutF_rRdPtr_rdCounter$D_IN = coutF_rRdPtr_rdCounterPre ;
  assign coutF_rRdPtr_rdCounter$EN = 1'd1 ;

  // register coutF_rRdPtr_rdCounterPre
  assign coutF_rRdPtr_rdCounterPre$D_IN = coutF_rRdPtr_rsCounter ;
  assign coutF_rRdPtr_rdCounterPre$EN = 1'd1 ;

  // register coutF_rRdPtr_rsCounter
  assign coutF_rRdPtr_rsCounter$D_IN =
	     MUX_coutF_rRdPtr_rsCounter$write_1__VAL_1 ;
  assign coutF_rRdPtr_rsCounter$EN = coutF_pwDequeue$whas ;

  // register coutF_rWrPtr_rdCounter
  assign coutF_rWrPtr_rdCounter$D_IN = coutF_rWrPtr_rdCounterPre ;
  assign coutF_rWrPtr_rdCounter$EN = 1'd1 ;

  // register coutF_rWrPtr_rdCounterPre
  assign coutF_rWrPtr_rdCounterPre$D_IN = coutF_rWrPtr_rsCounter ;
  assign coutF_rWrPtr_rdCounterPre$EN = 1'd1 ;

  // register coutF_rWrPtr_rsCounter
  assign coutF_rWrPtr_rsCounter$D_IN =
	     MUX_coutF_rWrPtr_rsCounter$write_1__VAL_1 ;
  assign coutF_rWrPtr_rsCounter$EN = coutF_pwEnqueue$whas ;

  // register dwRead
  assign dwRead$D_IN = 32'h0 ;
  assign dwRead$EN = 1'b0 ;

  // register dwWritten
  assign dwWritten$D_IN = 32'h0 ;
  assign dwWritten$EN = 1'b0 ;

  // register icapCtrl
  assign icapCtrl$D_IN = wci_wslv_reqF$D_OUT[31:0] ;
  assign icapCtrl$EN =
	     WILL_FIRE_RL_wci_cfwr &&
	     wci_wslv_reqF$D_OUT[63:32] == 32'h00000004 ;

  // register icap_icapBusy
  assign icap_icapBusy$D_IN = icap_icap$BUSY ;
  assign icap_icapBusy$EN = 1'd1 ;

  // register icap_icapCs
  assign icap_icapCs$D_IN = icap_icapCs_1$whas ;
  assign icap_icapCs$EN = 1'd1 ;

  // register icap_icapIn
  assign icap_icapIn$D_IN =
	     WILL_FIRE_RL_icap_write_configration_data ?
	       icap_icapIn_1$wget :
	       32'hFFFFFFFF ;
  assign icap_icapIn$EN = 1'd1 ;

  // register icap_icapOut
  assign icap_icapOut$D_IN = icap_icap$O ;
  assign icap_icapOut$EN = 1'd1 ;

  // register icap_icapRd
  assign icap_icapRd$D_IN =
	     icap_icapRd_1$whas &&
	     !WILL_FIRE_RL_icap_write_configration_data ;
  assign icap_icapRd$EN = 1'd1 ;

  // register icap_inCount
  assign icap_inCount$D_IN = icap_inCount + 32'd1 ;
  assign icap_inCount$EN = WILL_FIRE_RL_icap_write_configration_data ;

  // register icap_outCount
  assign icap_outCount$D_IN = icap_outCount + 32'd1 ;
  assign icap_outCount$EN =
	     WILL_FIRE_RL_icap_read_configuration_data && !icap_icapBusy ;

  // register wci_wslv_cEdge
  assign wci_wslv_cEdge$D_IN = wci_wslv_reqF$D_OUT[36:34] ;
  assign wci_wslv_cEdge$EN = WILL_FIRE_RL_wci_wslv_ctl_op_start ;

  // register wci_wslv_cState
  assign wci_wslv_cState$D_IN = wci_wslv_nState ;
  assign wci_wslv_cState$EN =
	     WILL_FIRE_RL_wci_wslv_ctl_op_complete && !wci_wslv_illegalEdge ;

  // register wci_wslv_ctlAckReg
  assign wci_wslv_ctlAckReg$D_IN = wci_wslv_ctlAckReg_1$whas ;
  assign wci_wslv_ctlAckReg$EN = 1'd1 ;

  // register wci_wslv_ctlOpActive
  assign wci_wslv_ctlOpActive$D_IN = !WILL_FIRE_RL_wci_wslv_ctl_op_complete ;
  assign wci_wslv_ctlOpActive$EN =
	     WILL_FIRE_RL_wci_wslv_ctl_op_complete ||
	     WILL_FIRE_RL_wci_wslv_ctl_op_start ;

  // register wci_wslv_illegalEdge
  assign wci_wslv_illegalEdge$D_IN =
	     MUX_wci_wslv_illegalEdge$write_1__SEL_1 &&
	     MUX_wci_wslv_illegalEdge$write_1__VAL_1 ;
  assign wci_wslv_illegalEdge$EN =
	     MUX_wci_wslv_illegalEdge$write_1__SEL_1 ||
	     WILL_FIRE_RL_wci_wslv_ctl_op_complete && wci_wslv_illegalEdge ;

  // register wci_wslv_isReset_isInReset
  assign wci_wslv_isReset_isInReset$D_IN = 1'd0 ;
  assign wci_wslv_isReset_isInReset$EN = wci_wslv_isReset_isInReset ;

  // register wci_wslv_nState
  always@(wci_wslv_reqF$D_OUT)
  begin
    case (wci_wslv_reqF$D_OUT[36:34])
      3'd0: wci_wslv_nState$D_IN = 3'd1;
      3'd1: wci_wslv_nState$D_IN = 3'd2;
      3'd2: wci_wslv_nState$D_IN = 3'd3;
      default: wci_wslv_nState$D_IN = 3'd0;
    endcase
  end
  assign wci_wslv_nState$EN =
	     WILL_FIRE_RL_wci_wslv_ctl_op_start &&
	     (wci_wslv_reqF$D_OUT[36:34] == 3'd0 && wci_wslv_cState == 3'd0 ||
	      wci_wslv_reqF$D_OUT[36:34] == 3'd1 &&
	      (wci_wslv_cState == 3'd1 || wci_wslv_cState == 3'd3) ||
	      wci_wslv_reqF$D_OUT[36:34] == 3'd2 && wci_wslv_cState == 3'd2 ||
	      wci_wslv_reqF$D_OUT[36:34] == 3'd3 &&
	      (wci_wslv_cState == 3'd3 || wci_wslv_cState == 3'd2 ||
	       wci_wslv_cState == 3'd1)) ;

  // register wci_wslv_reqF_countReg
  assign wci_wslv_reqF_countReg$D_IN =
	     (wci_wslv_wciReq$wget[71:69] != 3'd0) ?
	       wci_wslv_reqF_countReg + 2'd1 :
	       wci_wslv_reqF_countReg - 2'd1 ;
  assign wci_wslv_reqF_countReg$EN =
	     (wci_wslv_wciReq$wget[71:69] != 3'd0) !=
	     wci_wslv_reqF_r_deq$whas ;

  // register wci_wslv_respF_c_r
  assign wci_wslv_respF_c_r$D_IN =
	     WILL_FIRE_RL_wci_wslv_respF_incCtr ?
	       MUX_wci_wslv_respF_c_r$write_1__VAL_1 :
	       MUX_wci_wslv_respF_c_r$write_1__VAL_2 ;
  assign wci_wslv_respF_c_r$EN =
	     WILL_FIRE_RL_wci_wslv_respF_incCtr ||
	     WILL_FIRE_RL_wci_wslv_respF_decCtr ;

  // register wci_wslv_respF_q_0
  always@(WILL_FIRE_RL_wci_wslv_respF_both or
	  MUX_wci_wslv_respF_q_0$write_1__VAL_1 or
	  MUX_wci_wslv_respF_q_0$write_1__SEL_2 or
	  MUX_wci_wslv_respF_q_0$write_1__VAL_2 or
	  WILL_FIRE_RL_wci_wslv_respF_decCtr or wci_wslv_respF_q_1)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_wci_wslv_respF_both:
	  wci_wslv_respF_q_0$D_IN = MUX_wci_wslv_respF_q_0$write_1__VAL_1;
      MUX_wci_wslv_respF_q_0$write_1__SEL_2:
	  wci_wslv_respF_q_0$D_IN = MUX_wci_wslv_respF_q_0$write_1__VAL_2;
      WILL_FIRE_RL_wci_wslv_respF_decCtr:
	  wci_wslv_respF_q_0$D_IN = wci_wslv_respF_q_1;
      default: wci_wslv_respF_q_0$D_IN =
		   34'h2AAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign wci_wslv_respF_q_0$EN =
	     WILL_FIRE_RL_wci_wslv_respF_both ||
	     WILL_FIRE_RL_wci_wslv_respF_incCtr &&
	     wci_wslv_respF_c_r == 2'd0 ||
	     WILL_FIRE_RL_wci_wslv_respF_decCtr ;

  // register wci_wslv_respF_q_1
  always@(WILL_FIRE_RL_wci_wslv_respF_both or
	  MUX_wci_wslv_respF_q_1$write_1__VAL_1 or
	  MUX_wci_wslv_respF_q_1$write_1__SEL_2 or
	  MUX_wci_wslv_respF_q_0$write_1__VAL_2 or
	  WILL_FIRE_RL_wci_wslv_respF_decCtr)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_wci_wslv_respF_both:
	  wci_wslv_respF_q_1$D_IN = MUX_wci_wslv_respF_q_1$write_1__VAL_1;
      MUX_wci_wslv_respF_q_1$write_1__SEL_2:
	  wci_wslv_respF_q_1$D_IN = MUX_wci_wslv_respF_q_0$write_1__VAL_2;
      WILL_FIRE_RL_wci_wslv_respF_decCtr:
	  wci_wslv_respF_q_1$D_IN = 34'h0AAAAAAAA;
      default: wci_wslv_respF_q_1$D_IN =
		   34'h2AAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign wci_wslv_respF_q_1$EN =
	     WILL_FIRE_RL_wci_wslv_respF_both ||
	     WILL_FIRE_RL_wci_wslv_respF_incCtr &&
	     wci_wslv_respF_c_r == 2'd1 ||
	     WILL_FIRE_RL_wci_wslv_respF_decCtr ;

  // register wci_wslv_sFlagReg
  assign wci_wslv_sFlagReg$D_IN = 1'b0 ;
  assign wci_wslv_sFlagReg$EN = 1'd1 ;

  // register wci_wslv_sThreadBusy_d
  assign wci_wslv_sThreadBusy_d$D_IN = 1'b0 ;
  assign wci_wslv_sThreadBusy_d$EN = 1'd1 ;

  // submodule coutF_memory
  assign coutF_memory$ADDRA =
	     { coutF_rWrPtr_rsCounter_24_BIT_10_50_XOR_coutF__ETC___d654,
	       coutF_rWrPtr_rsCounter_24_BIT_10_50_XOR_coutF__ETC___d681,
	       coutF_rWrPtr_rsCounter_24_BIT_10_50_XOR_coutF__ETC___d656,
	       coutF_rWrPtr_rsCounter_24_BIT_10_50_XOR_coutF__ETC___d655,
	       coutF_rWrPtr_rsCounter_24_BIT_10_50_XOR_coutF__ETC___d657,
	       coutF_rWrPtr_rsCounter_24_BIT_10_50_XOR_coutF__ETC___d658,
	       coutF_rWrPtr_rsCounter_24_BIT_10_50_XOR_coutF__ETC___d660,
	       coutF_rWrPtr_rsCounter_24_BIT_10_50_XOR_coutF__ETC___d659,
	       coutF_rWrPtr_rsCounter_24_BIT_10_50_XOR_coutF__ETC___d661,
	       coutF_rWrPtr_rsCounter_24_BIT_10_50_XOR_coutF__ETC___d661 ^
	       coutF_rWrPtr_rsCounter[0] } ;
  assign coutF_memory$ADDRB =
	     coutF_pwDequeue$whas ? x__h22081[9:0] : x2__h22050 ;
  assign coutF_memory$DIA = x3__h20817 ;
  assign coutF_memory$DIB = 32'hAAAAAAAA /* unspecified value */  ;
  assign coutF_memory$WEA = coutF_pwEnqueue$whas ;
  assign coutF_memory$WEB = 1'd0 ;
  assign coutF_memory$ENA = 1'd1 ;
  assign coutF_memory$ENB = 1'd1 ;

  // submodule cre
  assign cre$sD_IN = icapCtrl[1] ;
  assign cre$sEN = cwe$sRDY && cre$sRDY && wci_wslv_cState == 3'd2 ;

  // submodule cwe
  assign cwe$sD_IN = icapCtrl[0] ;
  assign cwe$sEN = cwe$sRDY && cre$sRDY && wci_wslv_cState == 3'd2 ;

  // submodule icap_cinF
  assign icap_cinF$D_IN = cinS ;
  assign icap_cinF$ENQ = cinF_deq_pw$whas ;
  assign icap_cinF$DEQ = WILL_FIRE_RL_icap_write_configration_data ;
  assign icap_cinF$CLR = 1'b0 ;

  // submodule icap_coutF
  assign icap_coutF$D_IN =
	     { icap_icapOut[24],
	       icap_icapOut[25],
	       icap_icapOut[26],
	       icap_icapOut[27],
	       icap_icapOut[28],
	       icap_icapOut[29],
	       icap_icapOut[30],
	       icap_icapOut[31],
	       icap_icapOut[16],
	       icap_icapOut[17],
	       icap_icapOut[18],
	       icap_icapOut[19],
	       icap_icapOut[20],
	       icap_icapOut[21],
	       icap_icapOut[22],
	       icap_icapOut[23],
	       icap_icapOut[8],
	       icap_icapOut[9],
	       icap_icapOut[10],
	       icap_icapOut[11],
	       icap_icapOut[12],
	       icap_icapOut[13],
	       icap_icapOut[14],
	       icap_icapOut[15],
	       icap_icapOut[0],
	       icap_icapOut[1],
	       icap_icapOut[2],
	       icap_icapOut[3],
	       icap_icapOut[4],
	       icap_icapOut[5],
	       icap_icapOut[6],
	       icap_icapOut[7] } ;
  assign icap_coutF$ENQ =
	     WILL_FIRE_RL_icap_read_configuration_data && !icap_icapBusy ;
  assign icap_coutF$DEQ = coutF_pwEnqueue$whas ;
  assign icap_coutF$CLR = 1'b0 ;

  // submodule icap_icap
  assign icap_icap$CSB = !icap_icapCs ;
  assign icap_icap$I = icap_icapIn ;
  assign icap_icap$RDWRB = icap_icapRd ;

  // submodule inCnt
  assign inCnt$sD_IN = icap_inCount ;
  assign inCnt$sEN = inCnt$sRDY ;

  // submodule outCnt
  assign outCnt$sD_IN = icap_outCount ;
  assign outCnt$sEN = outCnt$sRDY ;

  // submodule wci_wslv_reqF
  assign wci_wslv_reqF$D_IN = wci_wslv_wciReq$wget ;
  assign wci_wslv_reqF$ENQ = wci_wslv_wciReq$wget[71:69] != 3'd0 ;
  assign wci_wslv_reqF$DEQ = wci_wslv_reqF_r_deq$whas ;
  assign wci_wslv_reqF$CLR = 1'b0 ;

  // remaining internal signals
  assign IF_coutF_rRdPtr_rsCounter_93_BIT_0_00_OR_coutF_ETC___d756 =
	     (coutF_rRdPtr_rsCounter[0] || coutF_rRdPtr_rsCounter[1] ||
	      coutF_rRdPtr_rsCounter[2] ||
	      coutF_rRdPtr_rsCounter[3] ||
	      coutF_rRdPtr_rsCounter[4] ||
	      coutF_rRdPtr_rsCounter[5] ||
	      coutF_rRdPtr_rsCounter[6] ||
	      coutF_rRdPtr_rsCounter[7] ||
	      coutF_rRdPtr_rsCounter[8] ||
	      coutF_rRdPtr_rsCounter[9]) ?
	       (coutF_rRdPtr_rsCounter[0] ?
		  32'd1 :
		  (coutF_rRdPtr_rsCounter[1] ?
		     32'd2 :
		     (coutF_rRdPtr_rsCounter[2] ?
			32'd3 :
			(coutF_rRdPtr_rsCounter[3] ?
			   32'd4 :
			   (coutF_rRdPtr_rsCounter[4] ?
			      32'd5 :
			      (coutF_rRdPtr_rsCounter[5] ?
				 32'd6 :
				 (coutF_rRdPtr_rsCounter[6] ?
				    32'd7 :
				    (coutF_rRdPtr_rsCounter[7] ?
				       32'd8 :
				       (coutF_rRdPtr_rsCounter[8] ?
					  32'd9 :
					  (coutF_rRdPtr_rsCounter[9] ?
					     32'd10 :
					     (coutF_rRdPtr_rsCounter[10] ?
						32'd11 :
						32'd12))))))))))) :
	       32'd10 ;
  assign IF_coutF_rWrPtr_rsCounter_24_BIT_0_31_OR_coutF_ETC___d755 =
	     (coutF_rWrPtr_rsCounter[0] || coutF_rWrPtr_rsCounter[1] ||
	      coutF_rWrPtr_rsCounter[2] ||
	      coutF_rWrPtr_rsCounter[3] ||
	      coutF_rWrPtr_rsCounter[4] ||
	      coutF_rWrPtr_rsCounter[5] ||
	      coutF_rWrPtr_rsCounter[6] ||
	      coutF_rWrPtr_rsCounter[7] ||
	      coutF_rWrPtr_rsCounter[8] ||
	      coutF_rWrPtr_rsCounter[9]) ?
	       (coutF_rWrPtr_rsCounter[0] ?
		  32'd1 :
		  (coutF_rWrPtr_rsCounter[1] ?
		     32'd2 :
		     (coutF_rWrPtr_rsCounter[2] ?
			32'd3 :
			(coutF_rWrPtr_rsCounter[3] ?
			   32'd4 :
			   (coutF_rWrPtr_rsCounter[4] ?
			      32'd5 :
			      (coutF_rWrPtr_rsCounter[5] ?
				 32'd6 :
				 (coutF_rWrPtr_rsCounter[6] ?
				    32'd7 :
				    (coutF_rWrPtr_rsCounter[7] ?
				       32'd8 :
				       (coutF_rWrPtr_rsCounter[8] ?
					  32'd9 :
					  (coutF_rWrPtr_rsCounter[9] ?
					     32'd10 :
					     (coutF_rWrPtr_rsCounter[10] ?
						32'd11 :
						32'd12))))))))))) :
	       32'd10 ;
  assign IF_coutF_rWrPtr_rsCounter_24_BIT_0_31_XOR_cout_ETC___d754 =
	     coutF_rWrPtr_rsCounter_24_BIT_0_31_XOR_coutF_r_ETC___d721 ?
	       IF_coutF_rWrPtr_rsCounter_24_BIT_0_31_OR_coutF_ETC___d755 :
	       32'd0 ;
  assign NOT_coutF_rRdPtr_rsCounter_93_EQ_coutF_rWrPtr__ETC___d601 =
	     coutF_rRdPtr_rsCounter != coutF_rWrPtr_rdCounter ;
  assign NOT_wci_wslv_respF_c_r_2_EQ_2_1_2_AND_wci_wslv_ETC___d592 =
	     wci_wslv_respF_c_r != 2'd2 && wci_wslv_reqF$EMPTY_N &&
	     (wci_wslv_reqF$D_OUT[63:32] != 32'h00000008 ||
	      cinF_head_wrapped == cinF_tail_wrapped && !cinF_sInReset$VAL &&
	      cd$PREEDGE) ;
  assign coutF_rRdPtr_rdCounter_24_BIT_10_25_CONCAT_cou_ETC___d675 =
	     x_dReadBin__h20521 + 11'd512 ;
  assign coutF_rRdPtr_rdCounter_24_BIT_10_25_XOR_coutF__ETC___d669 =
	     coutF_rRdPtr_rdCounter[10] ^ coutF_rRdPtr_rdCounter[9] ;
  assign coutF_rRdPtr_rdCounter_24_BIT_10_25_XOR_coutF__ETC___d670 =
	     coutF_rRdPtr_rdCounter_24_BIT_10_25_XOR_coutF__ETC___d669 ^
	     coutF_rRdPtr_rdCounter[8] ;
  assign coutF_rRdPtr_rdCounter_24_BIT_10_25_XOR_coutF__ETC___d671 =
	     coutF_rRdPtr_rdCounter_24_BIT_10_25_XOR_coutF__ETC___d683 ^
	     coutF_rRdPtr_rdCounter[6] ;
  assign coutF_rRdPtr_rdCounter_24_BIT_10_25_XOR_coutF__ETC___d672 =
	     coutF_rRdPtr_rdCounter_24_BIT_10_25_XOR_coutF__ETC___d671 ^
	     coutF_rRdPtr_rdCounter[5] ;
  assign coutF_rRdPtr_rdCounter_24_BIT_10_25_XOR_coutF__ETC___d673 =
	     coutF_rRdPtr_rdCounter_24_BIT_10_25_XOR_coutF__ETC___d678 ^
	     coutF_rRdPtr_rdCounter[3] ;
  assign coutF_rRdPtr_rdCounter_24_BIT_10_25_XOR_coutF__ETC___d674 =
	     coutF_rRdPtr_rdCounter_24_BIT_10_25_XOR_coutF__ETC___d673 ^
	     coutF_rRdPtr_rdCounter[2] ;
  assign coutF_rRdPtr_rdCounter_24_BIT_10_25_XOR_coutF__ETC___d676 =
	     coutF_rRdPtr_rdCounter_24_BIT_10_25_XOR_coutF__ETC___d674 ^
	     coutF_rRdPtr_rdCounter[1] ;
  assign coutF_rRdPtr_rdCounter_24_BIT_10_25_XOR_coutF__ETC___d678 =
	     coutF_rRdPtr_rdCounter_24_BIT_10_25_XOR_coutF__ETC___d672 ^
	     coutF_rRdPtr_rdCounter[4] ;
  assign coutF_rRdPtr_rdCounter_24_BIT_10_25_XOR_coutF__ETC___d683 =
	     coutF_rRdPtr_rdCounter_24_BIT_10_25_XOR_coutF__ETC___d670 ^
	     coutF_rRdPtr_rdCounter[7] ;
  assign coutF_rRdPtr_rsCounter_93_BIT_0_00_XOR_coutF_r_ETC___d722 =
	     z__h19695 ^ coutF_rRdPtr_rsCounter[10] ;
  assign coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d662 =
	     coutF_rRdPtr_rsCounter[10] ^ coutF_rRdPtr_rsCounter[9] ;
  assign coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d663 =
	     coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d662 ^
	     coutF_rRdPtr_rsCounter[8] ;
  assign coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d664 =
	     coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d663 ^
	     coutF_rRdPtr_rsCounter[7] ;
  assign coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d665 =
	     coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d664 ^
	     coutF_rRdPtr_rsCounter[6] ;
  assign coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d666 =
	     coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d680 ^
	     coutF_rRdPtr_rsCounter[4] ;
  assign coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d667 =
	     coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d666 ^
	     coutF_rRdPtr_rsCounter[3] ;
  assign coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d668 =
	     coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d682 ^
	     coutF_rRdPtr_rsCounter[1] ;
  assign coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d680 =
	     coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d665 ^
	     coutF_rRdPtr_rsCounter[5] ;
  assign coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d682 =
	     coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d667 ^
	     coutF_rRdPtr_rsCounter[2] ;
  assign coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d701 =
	     coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d668 ^
	     coutF_rRdPtr_rsCounter[0] ;
  assign coutF_rWrPtr_rsCounter_24_BIT_0_31_XOR_coutF_r_ETC___d721 =
	     z__h17393 ^ coutF_rWrPtr_rsCounter[10] ;
  assign coutF_rWrPtr_rsCounter_24_BIT_10_50_XOR_coutF__ETC___d654 =
	     coutF_rWrPtr_rsCounter[10] ^ coutF_rWrPtr_rsCounter[9] ;
  assign coutF_rWrPtr_rsCounter_24_BIT_10_50_XOR_coutF__ETC___d655 =
	     coutF_rWrPtr_rsCounter_24_BIT_10_50_XOR_coutF__ETC___d656 ^
	     coutF_rWrPtr_rsCounter[6] ;
  assign coutF_rWrPtr_rsCounter_24_BIT_10_50_XOR_coutF__ETC___d656 =
	     coutF_rWrPtr_rsCounter_24_BIT_10_50_XOR_coutF__ETC___d681 ^
	     coutF_rWrPtr_rsCounter[7] ;
  assign coutF_rWrPtr_rsCounter_24_BIT_10_50_XOR_coutF__ETC___d657 =
	     coutF_rWrPtr_rsCounter_24_BIT_10_50_XOR_coutF__ETC___d655 ^
	     coutF_rWrPtr_rsCounter[5] ;
  assign coutF_rWrPtr_rsCounter_24_BIT_10_50_XOR_coutF__ETC___d658 =
	     coutF_rWrPtr_rsCounter_24_BIT_10_50_XOR_coutF__ETC___d657 ^
	     coutF_rWrPtr_rsCounter[4] ;
  assign coutF_rWrPtr_rsCounter_24_BIT_10_50_XOR_coutF__ETC___d659 =
	     coutF_rWrPtr_rsCounter_24_BIT_10_50_XOR_coutF__ETC___d660 ^
	     coutF_rWrPtr_rsCounter[2] ;
  assign coutF_rWrPtr_rsCounter_24_BIT_10_50_XOR_coutF__ETC___d660 =
	     coutF_rWrPtr_rsCounter_24_BIT_10_50_XOR_coutF__ETC___d658 ^
	     coutF_rWrPtr_rsCounter[3] ;
  assign coutF_rWrPtr_rsCounter_24_BIT_10_50_XOR_coutF__ETC___d661 =
	     coutF_rWrPtr_rsCounter_24_BIT_10_50_XOR_coutF__ETC___d659 ^
	     coutF_rWrPtr_rsCounter[1] ;
  assign coutF_rWrPtr_rsCounter_24_BIT_10_50_XOR_coutF__ETC___d681 =
	     coutF_rWrPtr_rsCounter_24_BIT_10_50_XOR_coutF__ETC___d654 ^
	     coutF_rWrPtr_rsCounter[8] ;
  assign icapStatus__h26137 = { 29'd0, x__h26631 } ;
  assign rdat__h26538 = hasDebugLogic ? dwWritten : 32'd0 ;
  assign rdat__h26544 = hasDebugLogic ? dwRead : 32'd0 ;
  assign rdat__h26550 = hasDebugLogic ? inCnt$dD_OUT : 32'd0 ;
  assign rdat__h26556 = hasDebugLogic ? outCnt$dD_OUT : 32'd0 ;
  assign x2__h22050 =
	     { coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d662,
	       coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d663,
	       coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d664,
	       coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d665,
	       coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d680,
	       coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d666,
	       coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d667,
	       coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d682,
	       coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d668,
	       coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d701 } ;
  assign x3__h20817 = coutF_pwEnqueue$whas ? icap_coutF$D_OUT : 32'd0 ;
  assign x__h16406 =
	     11'd1 <<
	     IF_coutF_rWrPtr_rsCounter_24_BIT_0_31_XOR_cout_ETC___d754 ;
  assign x__h18708 = 11'd1 << x__h19564 ;
  assign x__h19564 =
	     coutF_rRdPtr_rsCounter_93_BIT_0_00_XOR_coutF_r_ETC___d722 ?
	       IF_coutF_rRdPtr_rsCounter_93_BIT_0_00_OR_coutF_ETC___d756 :
	       32'd0 ;
  assign x__h22081 = x_sReadBin__h20518 + 11'd1 ;
  assign x__h26631 =
	     { NOT_coutF_rRdPtr_rsCounter_93_EQ_coutF_rWrPtr__ETC___d601,
	       icapCtrl[1:0] } ;
  assign x_dReadBin__h20521 =
	     { coutF_rRdPtr_rdCounter[10],
	       coutF_rRdPtr_rdCounter_24_BIT_10_25_XOR_coutF__ETC___d669,
	       coutF_rRdPtr_rdCounter_24_BIT_10_25_XOR_coutF__ETC___d670,
	       coutF_rRdPtr_rdCounter_24_BIT_10_25_XOR_coutF__ETC___d683,
	       coutF_rRdPtr_rdCounter_24_BIT_10_25_XOR_coutF__ETC___d671,
	       coutF_rRdPtr_rdCounter_24_BIT_10_25_XOR_coutF__ETC___d672,
	       coutF_rRdPtr_rdCounter_24_BIT_10_25_XOR_coutF__ETC___d678,
	       coutF_rRdPtr_rdCounter_24_BIT_10_25_XOR_coutF__ETC___d673,
	       coutF_rRdPtr_rdCounter_24_BIT_10_25_XOR_coutF__ETC___d674,
	       coutF_rRdPtr_rdCounter_24_BIT_10_25_XOR_coutF__ETC___d676,
	       coutF_rRdPtr_rdCounter_24_BIT_10_25_XOR_coutF__ETC___d676 ^
	       coutF_rRdPtr_rdCounter[0] } ;
  assign x_sReadBin__h20518 =
	     { coutF_rRdPtr_rsCounter[10],
	       coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d662,
	       coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d663,
	       coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d664,
	       coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d665,
	       coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d680,
	       coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d666,
	       coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d667,
	       coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d682,
	       coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d668,
	       coutF_rRdPtr_rsCounter_93_BIT_10_19_XOR_coutF__ETC___d701 } ;
  assign y__h17293 = ~x__h16406 ;
  assign y__h19595 = ~x__h18708 ;
  assign z__h17337 = coutF_rWrPtr_rsCounter[0] ^ coutF_rWrPtr_rsCounter[1] ;
  assign z__h17344 = z__h17337 ^ coutF_rWrPtr_rsCounter[2] ;
  assign z__h17351 = z__h17344 ^ coutF_rWrPtr_rsCounter[3] ;
  assign z__h17358 = z__h17351 ^ coutF_rWrPtr_rsCounter[4] ;
  assign z__h17365 = z__h17358 ^ coutF_rWrPtr_rsCounter[5] ;
  assign z__h17372 = z__h17365 ^ coutF_rWrPtr_rsCounter[6] ;
  assign z__h17379 = z__h17372 ^ coutF_rWrPtr_rsCounter[7] ;
  assign z__h17386 = z__h17379 ^ coutF_rWrPtr_rsCounter[8] ;
  assign z__h17393 = z__h17386 ^ coutF_rWrPtr_rsCounter[9] ;
  assign z__h19639 = coutF_rRdPtr_rsCounter[0] ^ coutF_rRdPtr_rsCounter[1] ;
  assign z__h19646 = z__h19639 ^ coutF_rRdPtr_rsCounter[2] ;
  assign z__h19653 = z__h19646 ^ coutF_rRdPtr_rsCounter[3] ;
  assign z__h19660 = z__h19653 ^ coutF_rRdPtr_rsCounter[4] ;
  assign z__h19667 = z__h19660 ^ coutF_rRdPtr_rsCounter[5] ;
  assign z__h19674 = z__h19667 ^ coutF_rRdPtr_rsCounter[6] ;
  assign z__h19681 = z__h19674 ^ coutF_rRdPtr_rsCounter[7] ;
  assign z__h19688 = z__h19681 ^ coutF_rRdPtr_rsCounter[8] ;
  assign z__h19695 = z__h19688 ^ coutF_rRdPtr_rsCounter[9] ;
  always@(wci_wslv_reqF$D_OUT or
	  icapStatus__h26137 or
	  icapCtrl or
	  coutF_memory$DOB or
	  rdat__h26538 or rdat__h26544 or rdat__h26550 or rdat__h26556)
  begin
    case (wci_wslv_reqF$D_OUT[63:32])
      32'h0: v__h26514 = icapStatus__h26137;
      32'h00000004: v__h26514 = icapCtrl;
      32'h0000000C: v__h26514 = coutF_memory$DOB;
      32'h00000040: v__h26514 = rdat__h26538;
      32'h00000044: v__h26514 = rdat__h26544;
      32'h00000048: v__h26514 = rdat__h26550;
      32'h0000004C: v__h26514 = rdat__h26556;
      default: v__h26514 = 32'd0;
    endcase
  end

  // handling of inlined registers

  always@(posedge wciS0_Clk)
  begin
    if (wciS0_MReset_n == `BSV_RESET_VALUE)
      begin
        cinF_tail_wrapped <= `BSV_ASSIGNMENT_DELAY 1'd0;
	dwRead <= `BSV_ASSIGNMENT_DELAY 32'd0;
	dwWritten <= `BSV_ASSIGNMENT_DELAY 32'd0;
	icapCtrl <= `BSV_ASSIGNMENT_DELAY 32'd0;
	wci_wslv_cEdge <= `BSV_ASSIGNMENT_DELAY 3'h2;
	wci_wslv_cState <= `BSV_ASSIGNMENT_DELAY 3'd0;
	wci_wslv_ctlAckReg <= `BSV_ASSIGNMENT_DELAY 1'd0;
	wci_wslv_ctlOpActive <= `BSV_ASSIGNMENT_DELAY 1'd0;
	wci_wslv_illegalEdge <= `BSV_ASSIGNMENT_DELAY 1'd0;
	wci_wslv_nState <= `BSV_ASSIGNMENT_DELAY 3'd0;
	wci_wslv_reqF_countReg <= `BSV_ASSIGNMENT_DELAY 2'd0;
	wci_wslv_respF_c_r <= `BSV_ASSIGNMENT_DELAY 2'd0;
	wci_wslv_respF_q_0 <= `BSV_ASSIGNMENT_DELAY 34'h0AAAAAAAA;
	wci_wslv_respF_q_1 <= `BSV_ASSIGNMENT_DELAY 34'h0AAAAAAAA;
	wci_wslv_sFlagReg <= `BSV_ASSIGNMENT_DELAY 1'd0;
	wci_wslv_sThreadBusy_d <= `BSV_ASSIGNMENT_DELAY 1'd1;
      end
    else
      begin
        if (cinF_tail_wrapped$EN)
	  cinF_tail_wrapped <= `BSV_ASSIGNMENT_DELAY cinF_tail_wrapped$D_IN;
	if (dwRead$EN) dwRead <= `BSV_ASSIGNMENT_DELAY dwRead$D_IN;
	if (dwWritten$EN) dwWritten <= `BSV_ASSIGNMENT_DELAY dwWritten$D_IN;
	if (icapCtrl$EN) icapCtrl <= `BSV_ASSIGNMENT_DELAY icapCtrl$D_IN;
	if (wci_wslv_cEdge$EN)
	  wci_wslv_cEdge <= `BSV_ASSIGNMENT_DELAY wci_wslv_cEdge$D_IN;
	if (wci_wslv_cState$EN)
	  wci_wslv_cState <= `BSV_ASSIGNMENT_DELAY wci_wslv_cState$D_IN;
	if (wci_wslv_ctlAckReg$EN)
	  wci_wslv_ctlAckReg <= `BSV_ASSIGNMENT_DELAY wci_wslv_ctlAckReg$D_IN;
	if (wci_wslv_ctlOpActive$EN)
	  wci_wslv_ctlOpActive <= `BSV_ASSIGNMENT_DELAY
	      wci_wslv_ctlOpActive$D_IN;
	if (wci_wslv_illegalEdge$EN)
	  wci_wslv_illegalEdge <= `BSV_ASSIGNMENT_DELAY
	      wci_wslv_illegalEdge$D_IN;
	if (wci_wslv_nState$EN)
	  wci_wslv_nState <= `BSV_ASSIGNMENT_DELAY wci_wslv_nState$D_IN;
	if (wci_wslv_reqF_countReg$EN)
	  wci_wslv_reqF_countReg <= `BSV_ASSIGNMENT_DELAY
	      wci_wslv_reqF_countReg$D_IN;
	if (wci_wslv_respF_c_r$EN)
	  wci_wslv_respF_c_r <= `BSV_ASSIGNMENT_DELAY wci_wslv_respF_c_r$D_IN;
	if (wci_wslv_respF_q_0$EN)
	  wci_wslv_respF_q_0 <= `BSV_ASSIGNMENT_DELAY wci_wslv_respF_q_0$D_IN;
	if (wci_wslv_respF_q_1$EN)
	  wci_wslv_respF_q_1 <= `BSV_ASSIGNMENT_DELAY wci_wslv_respF_q_1$D_IN;
	if (wci_wslv_sFlagReg$EN)
	  wci_wslv_sFlagReg <= `BSV_ASSIGNMENT_DELAY wci_wslv_sFlagReg$D_IN;
	if (wci_wslv_sThreadBusy_d$EN)
	  wci_wslv_sThreadBusy_d <= `BSV_ASSIGNMENT_DELAY
	      wci_wslv_sThreadBusy_d$D_IN;
      end
    if (cinS$EN) cinS <= `BSV_ASSIGNMENT_DELAY cinS$D_IN;
  end

  always@(posedge cd$CLK_OUT)
  begin
    if (slowReset$OUT_RST == `BSV_RESET_VALUE)
      begin
        cinF_head_wrapped <= `BSV_ASSIGNMENT_DELAY 1'd0;
	icap_icapBusy <= `BSV_ASSIGNMENT_DELAY 1'd1;
	icap_icapCs <= `BSV_ASSIGNMENT_DELAY 1'd0;
	icap_icapIn <= `BSV_ASSIGNMENT_DELAY 32'hFFFFFFFF;
	icap_icapOut <= `BSV_ASSIGNMENT_DELAY 32'hFFFFFFFF;
	icap_icapRd <= `BSV_ASSIGNMENT_DELAY 1'd0;
	icap_inCount <= `BSV_ASSIGNMENT_DELAY 32'd0;
	icap_outCount <= `BSV_ASSIGNMENT_DELAY 32'd0;
      end
    else
      begin
        if (cinF_head_wrapped$EN)
	  cinF_head_wrapped <= `BSV_ASSIGNMENT_DELAY cinF_head_wrapped$D_IN;
	if (icap_icapBusy$EN)
	  icap_icapBusy <= `BSV_ASSIGNMENT_DELAY icap_icapBusy$D_IN;
	if (icap_icapCs$EN)
	  icap_icapCs <= `BSV_ASSIGNMENT_DELAY icap_icapCs$D_IN;
	if (icap_icapIn$EN)
	  icap_icapIn <= `BSV_ASSIGNMENT_DELAY icap_icapIn$D_IN;
	if (icap_icapOut$EN)
	  icap_icapOut <= `BSV_ASSIGNMENT_DELAY icap_icapOut$D_IN;
	if (icap_icapRd$EN)
	  icap_icapRd <= `BSV_ASSIGNMENT_DELAY icap_icapRd$D_IN;
	if (icap_inCount$EN)
	  icap_inCount <= `BSV_ASSIGNMENT_DELAY icap_inCount$D_IN;
	if (icap_outCount$EN)
	  icap_outCount <= `BSV_ASSIGNMENT_DELAY icap_outCount$D_IN;
      end
  end

  always@(posedge wciS0_Clk or `BSV_RESET_EDGE wciS0_MReset_n)
  if (wciS0_MReset_n == `BSV_RESET_VALUE)
    begin
      coutF_rRdPtr_rsCounter <= `BSV_ASSIGNMENT_DELAY 11'd0;
      coutF_rWrPtr_rdCounter <= `BSV_ASSIGNMENT_DELAY 11'd0;
      coutF_rWrPtr_rdCounterPre <= `BSV_ASSIGNMENT_DELAY 11'd0;
      wci_wslv_isReset_isInReset <= `BSV_ASSIGNMENT_DELAY 1'd1;
    end
  else
    begin
      if (coutF_rRdPtr_rsCounter$EN)
	coutF_rRdPtr_rsCounter <= `BSV_ASSIGNMENT_DELAY
	    coutF_rRdPtr_rsCounter$D_IN;
      if (coutF_rWrPtr_rdCounter$EN)
	coutF_rWrPtr_rdCounter <= `BSV_ASSIGNMENT_DELAY
	    coutF_rWrPtr_rdCounter$D_IN;
      if (coutF_rWrPtr_rdCounterPre$EN)
	coutF_rWrPtr_rdCounterPre <= `BSV_ASSIGNMENT_DELAY
	    coutF_rWrPtr_rdCounterPre$D_IN;
      if (wci_wslv_isReset_isInReset$EN)
	wci_wslv_isReset_isInReset <= `BSV_ASSIGNMENT_DELAY
	    wci_wslv_isReset_isInReset$D_IN;
    end

  always@(posedge cd$CLK_OUT or `BSV_RESET_EDGE slowReset$OUT_RST)
  if (slowReset$OUT_RST == `BSV_RESET_VALUE)
    begin
      coutF_rRdPtr_rdCounter <= `BSV_ASSIGNMENT_DELAY 11'd0;
      coutF_rRdPtr_rdCounterPre <= `BSV_ASSIGNMENT_DELAY 11'd0;
      coutF_rWrPtr_rsCounter <= `BSV_ASSIGNMENT_DELAY 11'd0;
    end
  else
    begin
      if (coutF_rRdPtr_rdCounter$EN)
	coutF_rRdPtr_rdCounter <= `BSV_ASSIGNMENT_DELAY
	    coutF_rRdPtr_rdCounter$D_IN;
      if (coutF_rRdPtr_rdCounterPre$EN)
	coutF_rRdPtr_rdCounterPre <= `BSV_ASSIGNMENT_DELAY
	    coutF_rRdPtr_rdCounterPre$D_IN;
      if (coutF_rWrPtr_rsCounter$EN)
	coutF_rWrPtr_rsCounter <= `BSV_ASSIGNMENT_DELAY
	    coutF_rWrPtr_rsCounter$D_IN;
    end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    cinF_head_wrapped = 1'h0;
    cinF_tail_wrapped = 1'h0;
    cinS = 32'hAAAAAAAA;
    coutF_rRdPtr_rdCounter = 11'h2AA;
    coutF_rRdPtr_rdCounterPre = 11'h2AA;
    coutF_rRdPtr_rsCounter = 11'h2AA;
    coutF_rWrPtr_rdCounter = 11'h2AA;
    coutF_rWrPtr_rdCounterPre = 11'h2AA;
    coutF_rWrPtr_rsCounter = 11'h2AA;
    dwRead = 32'hAAAAAAAA;
    dwWritten = 32'hAAAAAAAA;
    icapCtrl = 32'hAAAAAAAA;
    icap_icapBusy = 1'h0;
    icap_icapCs = 1'h0;
    icap_icapIn = 32'hAAAAAAAA;
    icap_icapOut = 32'hAAAAAAAA;
    icap_icapRd = 1'h0;
    icap_inCount = 32'hAAAAAAAA;
    icap_outCount = 32'hAAAAAAAA;
    wci_wslv_cEdge = 3'h2;
    wci_wslv_cState = 3'h2;
    wci_wslv_ctlAckReg = 1'h0;
    wci_wslv_ctlOpActive = 1'h0;
    wci_wslv_illegalEdge = 1'h0;
    wci_wslv_isReset_isInReset = 1'h0;
    wci_wslv_nState = 3'h2;
    wci_wslv_reqF_countReg = 2'h2;
    wci_wslv_respF_c_r = 2'h2;
    wci_wslv_respF_q_0 = 34'h2AAAAAAAA;
    wci_wslv_respF_q_1 = 34'h2AAAAAAAA;
    wci_wslv_sFlagReg = 1'h0;
    wci_wslv_sThreadBusy_d = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge wciS0_Clk)
  begin
    #0;
    if (wciS0_MReset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_wci_wslv_ctl_op_start)
	begin
	  v__h3695 = $time;
	  #0;
	end
    if (wciS0_MReset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_wci_wslv_ctl_op_start)
	$display("[%0d]: %m: WCI ControlOp: Starting-transition edge:%x from:%x",
		 v__h3695,
		 wci_wslv_reqF$D_OUT[36:34],
		 wci_wslv_cState);
    if (wciS0_MReset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_wci_ctrl_IsO)
	begin
	  v__h26767 = $time;
	  #0;
	end
    if (wciS0_MReset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_wci_ctrl_IsO)
	$display("[%0d]: %m: Starting ICAPWorker", v__h26767);
    if (wciS0_MReset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_wci_ctrl_IsO && WILL_FIRE_RL_wci_ctrl_OrE)
	$display("Error: \"bsv/wrk/ICAPWorker.bsv\", line 77, column 60: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_wci_ctrl_IsO] and\n  [RL_wci_ctrl_OrE] ) fired in the same clock cycle.\n");
    if (wciS0_MReset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_wci_ctrl_EiI && WILL_FIRE_RL_wci_ctrl_OrE)
	$display("Error: \"bsv/wrk/ICAPWorker.bsv\", line 77, column 46: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_wci_ctrl_EiI] and\n  [RL_wci_ctrl_OrE] ) fired in the same clock cycle.\n");
    if (wciS0_MReset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_wci_ctrl_EiI && WILL_FIRE_RL_wci_ctrl_IsO)
	$display("Error: \"bsv/wrk/ICAPWorker.bsv\", line 77, column 46: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_wci_ctrl_EiI] and\n  [RL_wci_ctrl_IsO] ) fired in the same clock cycle.\n");
    if (wciS0_MReset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_wci_wslv_ctl_op_complete && wci_wslv_illegalEdge)
	begin
	  v__h4014 = $time;
	  #0;
	end
    if (wciS0_MReset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_wci_wslv_ctl_op_complete && wci_wslv_illegalEdge)
	$display("[%0d]: %m: WCI ControlOp: ILLEGAL-EDGE Completed-transition edge:%x from:%x",
		 v__h4014,
		 wci_wslv_cEdge,
		 wci_wslv_cState);
    if (wciS0_MReset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_wci_wslv_ctl_op_complete && !wci_wslv_illegalEdge)
	begin
	  v__h3870 = $time;
	  #0;
	end
    if (wciS0_MReset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_wci_wslv_ctl_op_complete && !wci_wslv_illegalEdge)
	$display("[%0d]: %m: WCI ControlOp: Completed-transition edge:%x from:%x to:%x",
		 v__h3870,
		 wci_wslv_cEdge,
		 wci_wslv_cState,
		 wci_wslv_nState);
    if (wciS0_MReset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_wci_cfwr && WILL_FIRE_RL_wci_ctrl_OrE)
	$display("Error: \"bsv/wrk/ICAPWorker.bsv\", line 77, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_wci_cfwr] and\n  [RL_wci_ctrl_OrE] ) fired in the same clock cycle.\n");
    if (wciS0_MReset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_wci_cfwr && WILL_FIRE_RL_wci_ctrl_IsO)
	$display("Error: \"bsv/wrk/ICAPWorker.bsv\", line 77, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_wci_cfwr] and\n  [RL_wci_ctrl_IsO] ) fired in the same clock cycle.\n");
    if (wciS0_MReset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_wci_cfwr && WILL_FIRE_RL_wci_ctrl_EiI)
	$display("Error: \"bsv/wrk/ICAPWorker.bsv\", line 77, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_wci_cfwr] and\n  [RL_wci_ctrl_EiI] ) fired in the same clock cycle.\n");
    if (wciS0_MReset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_wci_cfwr && WILL_FIRE_RL_wci_cfrd)
	$display("Error: \"bsv/wrk/ICAPWorker.bsv\", line 77, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_wci_cfwr] and [RL_wci_cfrd] )\n  fired in the same clock cycle.\n");
    if (wciS0_MReset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_wci_cfrd && WILL_FIRE_RL_wci_ctrl_OrE)
	$display("Error: \"bsv/wrk/ICAPWorker.bsv\", line 77, column 36: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_wci_cfrd] and\n  [RL_wci_ctrl_OrE] ) fired in the same clock cycle.\n");
    if (wciS0_MReset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_wci_cfrd && WILL_FIRE_RL_wci_ctrl_IsO)
	$display("Error: \"bsv/wrk/ICAPWorker.bsv\", line 77, column 36: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_wci_cfrd] and\n  [RL_wci_ctrl_IsO] ) fired in the same clock cycle.\n");
    if (wciS0_MReset_n != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_wci_cfrd && WILL_FIRE_RL_wci_ctrl_EiI)
	$display("Error: \"bsv/wrk/ICAPWorker.bsv\", line 77, column 36: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_wci_cfrd] and\n  [RL_wci_ctrl_EiI] ) fired in the same clock cycle.\n");
  end
  // synopsys translate_on

  // synopsys translate_off
  always@(negedge cd$CLK_OUT)
  begin
    #0;
    if (slowReset$OUT_RST != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_icap_write_configration_data &&
	  WILL_FIRE_RL_icap_read_configuration_data)
	$display("Error: \"bsv/dev/ICAP.bsv\", line 127, column 28: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_icap_write_configration_data]\n  and [RL_icap_read_configuration_data] ) fired in the same clock cycle.\n");
  end
  // synopsys translate_on
endmodule  // mkICAPWorker
