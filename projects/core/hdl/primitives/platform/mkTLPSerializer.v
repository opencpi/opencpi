/*
 * This file is protected by Copyright. Please refer to the COPYRIGHT file
 * distributed with this source distribution.
 *
 * This file is part of OpenCPI <http://www.opencpi.org>
 *
 * OpenCPI is free software: you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * OpenCPI is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

//
// Generated by Bluespec Compiler, version 2013.01.beta5 (build 30325, 2013-01-23)
//
// On Fri Jun 21 17:00:49 EDT 2013
//
//
// Ports:
// Name                         I/O  size props
// RDY_server_request_put         O     1 reg
// server_response_get            O   153 reg
// RDY_server_response_get        O     1 reg
// client_request_get             O    61 reg
// RDY_client_request_get         O     1 reg
// RDY_client_response_put        O     1 reg
// pciDevice                      I    16
// CLK                            I     1 clock
// RST_N                          I     1 reset
// server_request_put             I   153 reg
// client_response_put            I    40 reg
// EN_server_request_put          I     1
// EN_client_response_put         I     1
// EN_server_response_get         I     1
// EN_client_request_get          I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkTLPSerializer(pciDevice,
		       CLK,
		       RST_N,

		       server_request_put,
		       EN_server_request_put,
		       RDY_server_request_put,

		       EN_server_response_get,
		       server_response_get,
		       RDY_server_response_get,

		       EN_client_request_get,
		       client_request_get,
		       RDY_client_request_get,

		       client_response_put,
		       EN_client_response_put,
		       RDY_client_response_put);
  input  [15 : 0] pciDevice;
  input  CLK;
  input  RST_N;

  // action method server_request_put
  input  [152 : 0] server_request_put;
  input  EN_server_request_put;
  output RDY_server_request_put;

  // actionvalue method server_response_get
  input  EN_server_response_get;
  output [152 : 0] server_response_get;
  output RDY_server_response_get;

  // actionvalue method client_request_get
  input  EN_client_request_get;
  output [60 : 0] client_request_get;
  output RDY_client_request_get;

  // action method client_response_put
  input  [39 : 0] client_response_put;
  input  EN_client_response_put;
  output RDY_client_response_put;

  // signals for module outputs
  wire [152 : 0] server_response_get;
  wire [60 : 0] client_request_get;
  wire RDY_client_request_get,
       RDY_client_response_put,
       RDY_server_request_put,
       RDY_server_response_get;

  // register cmpActive
  reg cmpActive;
  wire cmpActive$D_IN, cmpActive$EN;

  // register cmpDWRemain
  reg [9 : 0] cmpDWRemain;
  wire [9 : 0] cmpDWRemain$D_IN;
  wire cmpDWRemain$EN;

  // register rdp
  reg [1 : 0] rdp;
  wire [1 : 0] rdp$D_IN;
  wire rdp$EN;

  // register rdv
  reg [127 : 0] rdv;
  wire [127 : 0] rdv$D_IN;
  wire rdv$EN;

  // register rss
  reg [1 : 0] rss;
  wire [1 : 0] rss$D_IN;
  wire rss$EN;

  // register tlpActive
  reg tlpActive;
  wire tlpActive$D_IN, tlpActive$EN;

  // register tlpDW
  reg [31 : 0] tlpDW;
  wire [31 : 0] tlpDW$D_IN;
  wire tlpDW$EN;

  // register tlpDWAddr
  reg [29 : 0] tlpDWAddr;
  wire [29 : 0] tlpDWAddr$D_IN;
  wire tlpDWAddr$EN;

  // register tlpDWp
  reg [1 : 0] tlpDWp;
  wire [1 : 0] tlpDWp$D_IN;
  wire tlpDWp$EN;

  // register tlpFirst
  reg tlpFirst;
  wire tlpFirst$D_IN, tlpFirst$EN;

  // register tlpReq
  reg [63 : 0] tlpReq;
  wire [63 : 0] tlpReq$D_IN;
  wire tlpReq$EN;

  // register tlpUnroll
  reg [9 : 0] tlpUnroll;
  wire [9 : 0] tlpUnroll$D_IN;
  wire tlpUnroll$EN;

  // ports of submodule cmpF
  wire [55 : 0] cmpF$D_IN, cmpF$D_OUT;
  wire cmpF$CLR, cmpF$DEQ, cmpF$EMPTY_N, cmpF$ENQ, cmpF$FULL_N;

  // ports of submodule cpReqF
  wire [60 : 0] cpReqF$D_IN, cpReqF$D_OUT;
  wire cpReqF$CLR, cpReqF$DEQ, cpReqF$EMPTY_N, cpReqF$ENQ, cpReqF$FULL_N;

  // ports of submodule cpRespF
  wire [39 : 0] cpRespF$D_IN, cpRespF$D_OUT;
  wire cpRespF$CLR, cpRespF$DEQ, cpRespF$EMPTY_N, cpRespF$ENQ, cpRespF$FULL_N;

  // ports of submodule inF
  wire [152 : 0] inF$D_IN, inF$D_OUT;
  wire inF$CLR, inF$DEQ, inF$EMPTY_N, inF$ENQ, inF$FULL_N;

  // ports of submodule outF
  wire [152 : 0] outF$D_IN, outF$D_OUT;
  wire outF$CLR, outF$DEQ, outF$EMPTY_N, outF$ENQ, outF$FULL_N;

  // rule scheduling signals
  wire WILL_FIRE_RL_tlpFirstComplWord,
       WILL_FIRE_RL_tlpFirstRcv,
       WILL_FIRE_RL_tlpNextComplWord,
       WILL_FIRE_RL_tlpReqGen,
       WILL_FIRE_RL_tlpStageNextWord;

  // inputs to muxes for submodule ports
  wire [152 : 0] MUX_outF$enq_1__VAL_1, MUX_outF$enq_1__VAL_2;
  wire [29 : 0] MUX_tlpDWAddr$write_1__VAL_2;
  wire [9 : 0] MUX_cmpDWRemain$write_1__VAL_1,
	       MUX_cmpDWRemain$write_1__VAL_2,
	       MUX_tlpUnroll$write_1__VAL_2;
  wire [1 : 0] MUX_rdp$write_1__VAL_1,
	       MUX_rss$write_1__VAL_2,
	       MUX_tlpDWp$write_1__VAL_1;
  wire MUX_cmpActive$write_1__SEL_1,
       MUX_tlpActive$write_1__SEL_1,
       MUX_tlpDWAddr$write_1__SEL_1,
       MUX_tlpDWp$write_1__SEL_1;

  // remaining internal signals
  reg [31 : 0] v__h2549;
  reg [15 : 0] lastRema__h7245;
  reg [1 : 0] lowAddr10__h2074, x__h2304, x__h2327;
  wire [127 : 0] pkt__h4230, pw_data__h7278;
  wire [59 : 0] IF_tlpReq_3_BIT_62_4_THEN_tlpDWAddr_8_BITS_21__ETC___d113;
  wire [31 : 0] IF_tlpReq_3_BIT_62_4_AND_NOT_tlpFirst_6_4_5_TH_ETC___d102,
		wreq_data__h3050;
  wire [15 : 0] pw_be__h7277;
  wire [11 : 0] byteCount__h2076, x__h2295, x__h2297, y__h2296, y__h2298;
  wire [6 : 0] lowAddr__h2075;
  wire [3 : 0] _theResult_____2__h2491;
  wire [2 : 0] x__h7701;
  wire cpReqF_i_notFull__2_AND_NOT_tlpReq_3_BIT_62_4__ETC___d82;

  // action method server_request_put
  assign RDY_server_request_put = inF$FULL_N ;

  // actionvalue method server_response_get
  assign server_response_get = outF$D_OUT ;
  assign RDY_server_response_get = outF$EMPTY_N ;

  // actionvalue method client_request_get
  assign client_request_get = cpReqF$D_OUT ;
  assign RDY_client_request_get = cpReqF$EMPTY_N ;

  // action method client_response_put
  assign RDY_client_response_put = cpRespF$FULL_N ;

  // submodule cmpF
  FIFO2 #(.width(32'd56), .guarded(32'd1)) cmpF(.RST(RST_N),
						.CLK(CLK),
						.D_IN(cmpF$D_IN),
						.ENQ(cmpF$ENQ),
						.DEQ(cmpF$DEQ),
						.CLR(cmpF$CLR),
						.D_OUT(cmpF$D_OUT),
						.FULL_N(cmpF$FULL_N),
						.EMPTY_N(cmpF$EMPTY_N));

  // submodule cpReqF
  FIFO2 #(.width(32'd61), .guarded(32'd1)) cpReqF(.RST(RST_N),
						  .CLK(CLK),
						  .D_IN(cpReqF$D_IN),
						  .ENQ(cpReqF$ENQ),
						  .DEQ(cpReqF$DEQ),
						  .CLR(cpReqF$CLR),
						  .D_OUT(cpReqF$D_OUT),
						  .FULL_N(cpReqF$FULL_N),
						  .EMPTY_N(cpReqF$EMPTY_N));

  // submodule cpRespF
  FIFO2 #(.width(32'd40), .guarded(32'd1)) cpRespF(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(cpRespF$D_IN),
						   .ENQ(cpRespF$ENQ),
						   .DEQ(cpRespF$DEQ),
						   .CLR(cpRespF$CLR),
						   .D_OUT(cpRespF$D_OUT),
						   .FULL_N(cpRespF$FULL_N),
						   .EMPTY_N(cpRespF$EMPTY_N));

  // submodule inF
  FIFO2 #(.width(32'd153), .guarded(32'd1)) inF(.RST(RST_N),
						.CLK(CLK),
						.D_IN(inF$D_IN),
						.ENQ(inF$ENQ),
						.DEQ(inF$DEQ),
						.CLR(inF$CLR),
						.D_OUT(inF$D_OUT),
						.FULL_N(inF$FULL_N),
						.EMPTY_N(inF$EMPTY_N));

  // submodule outF
  FIFO2 #(.width(32'd153), .guarded(32'd1)) outF(.RST(RST_N),
						 .CLK(CLK),
						 .D_IN(outF$D_IN),
						 .ENQ(outF$ENQ),
						 .DEQ(outF$DEQ),
						 .CLR(outF$CLR),
						 .D_OUT(outF$D_OUT),
						 .FULL_N(outF$FULL_N),
						 .EMPTY_N(outF$EMPTY_N));

  // rule RL_tlpFirstRcv
  assign WILL_FIRE_RL_tlpFirstRcv =
	     inF$EMPTY_N &&
	     (!inF$D_OUT[152] || inF$D_OUT[110] || inF$D_OUT[125] ||
	      inF$D_OUT[124:120] != 5'b0 ||
	      inF$D_OUT[126] ||
	      cmpF$FULL_N) &&
	     !tlpActive ;

  // rule RL_tlpReqGen
  assign WILL_FIRE_RL_tlpReqGen =
	     cpReqF_i_notFull__2_AND_NOT_tlpReq_3_BIT_62_4__ETC___d82 &&
	     tlpActive ;

  // rule RL_tlpFirstComplWord
  assign WILL_FIRE_RL_tlpFirstComplWord =
	     cmpF$EMPTY_N && cpRespF$EMPTY_N && outF$FULL_N && !cmpActive ;

  // rule RL_tlpStageNextWord
  assign WILL_FIRE_RL_tlpStageNextWord =
	     cpRespF$EMPTY_N && cmpActive && cmpDWRemain != 10'd0 &&
	     !WILL_FIRE_RL_tlpNextComplWord ;

  // rule RL_tlpNextComplWord
  assign WILL_FIRE_RL_tlpNextComplWord =
	     outF$FULL_N && cmpActive && rss != 2'd0 ;

  // inputs to muxes for submodule ports
  assign MUX_cmpActive$write_1__SEL_1 =
	     WILL_FIRE_RL_tlpNextComplWord && rss == 2'd2 ;
  assign MUX_tlpActive$write_1__SEL_1 =
	     WILL_FIRE_RL_tlpReqGen && tlpUnroll == 10'd1 ;
  assign MUX_tlpDWAddr$write_1__SEL_1 =
	     WILL_FIRE_RL_tlpFirstRcv && inF$D_OUT[152] && !inF$D_OUT[110] &&
	     !inF$D_OUT[125] &&
	     inF$D_OUT[124:120] == 5'b0 ;
  assign MUX_tlpDWp$write_1__SEL_1 =
	     WILL_FIRE_RL_tlpReqGen && tlpReq[62] && !tlpFirst ;
  assign MUX_cmpDWRemain$write_1__VAL_1 = cmpF$D_OUT[21:12] - 10'd1 ;
  assign MUX_cmpDWRemain$write_1__VAL_2 = cmpDWRemain - 10'd1 ;
  assign MUX_outF$enq_1__VAL_1 =
	     { 1'd1, cmpF$D_OUT[21:12] == 10'd1, 23'h2AFFFF, pkt__h4230 } ;
  assign MUX_outF$enq_1__VAL_2 =
	     { 1'd0, rss == 2'd2, 7'h2A, pw_be__h7277, pw_data__h7278 } ;
  assign MUX_rdp$write_1__VAL_1 = rdp + 2'd1 ;
  assign MUX_rss$write_1__VAL_2 = (cmpDWRemain == 10'd1) ? 2'd2 : 2'd1 ;
  assign MUX_tlpDWAddr$write_1__VAL_2 = tlpDWAddr + 30'd1 ;
  assign MUX_tlpDWp$write_1__VAL_1 = tlpDWp - 2'd1 ;
  assign MUX_tlpUnroll$write_1__VAL_2 = tlpUnroll - 10'd1 ;

  // register cmpActive
  assign cmpActive$D_IN = !MUX_cmpActive$write_1__SEL_1 ;
  assign cmpActive$EN =
	     WILL_FIRE_RL_tlpNextComplWord && rss == 2'd2 ||
	     WILL_FIRE_RL_tlpFirstComplWord && cmpF$D_OUT[21:12] != 10'd1 ;

  // register cmpDWRemain
  assign cmpDWRemain$D_IN =
	     WILL_FIRE_RL_tlpFirstComplWord ?
	       MUX_cmpDWRemain$write_1__VAL_1 :
	       MUX_cmpDWRemain$write_1__VAL_2 ;
  assign cmpDWRemain$EN =
	     WILL_FIRE_RL_tlpFirstComplWord || WILL_FIRE_RL_tlpStageNextWord ;

  // register rdp
  assign rdp$D_IN =
	     WILL_FIRE_RL_tlpStageNextWord ? MUX_rdp$write_1__VAL_1 : 2'd0 ;
  assign rdp$EN =
	     WILL_FIRE_RL_tlpStageNextWord || WILL_FIRE_RL_tlpNextComplWord ;

  // register rdv
  assign rdv$D_IN =
	     { rdv[95:0],
	       cpRespF$D_OUT[7:0],
	       cpRespF$D_OUT[15:8],
	       cpRespF$D_OUT[23:16],
	       cpRespF$D_OUT[31:24] } ;
  assign rdv$EN = WILL_FIRE_RL_tlpStageNextWord ;

  // register rss
  assign rss$D_IN =
	     MUX_cmpActive$write_1__SEL_1 ? 2'd0 : MUX_rss$write_1__VAL_2 ;
  assign rss$EN =
	     WILL_FIRE_RL_tlpNextComplWord && rss == 2'd2 ||
	     WILL_FIRE_RL_tlpStageNextWord &&
	     (cmpDWRemain == 10'd1 || rdp == 2'd3) ;

  // register tlpActive
  assign tlpActive$D_IN = !MUX_tlpActive$write_1__SEL_1 ;
  assign tlpActive$EN =
	     WILL_FIRE_RL_tlpReqGen && tlpUnroll == 10'd1 ||
	     WILL_FIRE_RL_tlpFirstRcv ;

  // register tlpDW
  assign tlpDW$D_IN = inF$D_OUT[31:0] ;
  assign tlpDW$EN = MUX_tlpDWAddr$write_1__SEL_1 ;

  // register tlpDWAddr
  assign tlpDWAddr$D_IN =
	     MUX_tlpDWAddr$write_1__SEL_1 ?
	       inF$D_OUT[63:34] :
	       MUX_tlpDWAddr$write_1__VAL_2 ;
  assign tlpDWAddr$EN =
	     WILL_FIRE_RL_tlpFirstRcv && inF$D_OUT[152] && !inF$D_OUT[110] &&
	     !inF$D_OUT[125] &&
	     inF$D_OUT[124:120] == 5'b0 ||
	     WILL_FIRE_RL_tlpReqGen ;

  // register tlpDWp
  assign tlpDWp$D_IN =
	     MUX_tlpDWp$write_1__SEL_1 ? MUX_tlpDWp$write_1__VAL_1 : 2'd3 ;
  assign tlpDWp$EN =
	     WILL_FIRE_RL_tlpReqGen && tlpReq[62] && !tlpFirst ||
	     WILL_FIRE_RL_tlpFirstRcv && inF$D_OUT[152] && !inF$D_OUT[110] &&
	     !inF$D_OUT[125] &&
	     inF$D_OUT[124:120] == 5'b0 ;

  // register tlpFirst
  assign tlpFirst$D_IN = MUX_tlpDWAddr$write_1__SEL_1 ;
  assign tlpFirst$EN =
	     WILL_FIRE_RL_tlpFirstRcv && inF$D_OUT[152] && !inF$D_OUT[110] &&
	     !inF$D_OUT[125] &&
	     inF$D_OUT[124:120] == 5'b0 ||
	     WILL_FIRE_RL_tlpReqGen ;

  // register tlpReq
  assign tlpReq$D_IN =
	     { 1'b0,
	       inF$D_OUT[126:120],
	       1'b0,
	       inF$D_OUT[118:116],
	       4'b0,
	       inF$D_OUT[111:108],
	       2'b0,
	       inF$D_OUT[105:64] } ;
  assign tlpReq$EN = MUX_tlpDWAddr$write_1__SEL_1 ;

  // register tlpUnroll
  assign tlpUnroll$D_IN =
	     MUX_tlpDWAddr$write_1__SEL_1 ?
	       inF$D_OUT[105:96] :
	       MUX_tlpUnroll$write_1__VAL_2 ;
  assign tlpUnroll$EN =
	     WILL_FIRE_RL_tlpFirstRcv && inF$D_OUT[152] && !inF$D_OUT[110] &&
	     !inF$D_OUT[125] &&
	     inF$D_OUT[124:120] == 5'b0 ||
	     WILL_FIRE_RL_tlpReqGen ;

  // submodule cmpF
  assign cmpF$D_IN =
	     { inF$D_OUT[95:80],
	       inF$D_OUT[118:116],
	       inF$D_OUT[79:72],
	       lowAddr__h2075,
	       inF$D_OUT[105:96],
	       byteCount__h2076 } ;
  assign cmpF$ENQ =
	     WILL_FIRE_RL_tlpFirstRcv && inF$D_OUT[152] && !inF$D_OUT[110] &&
	     !inF$D_OUT[125] &&
	     inF$D_OUT[124:120] == 5'b0 &&
	     !inF$D_OUT[126] ;
  assign cmpF$DEQ = WILL_FIRE_RL_tlpFirstComplWord ;
  assign cmpF$CLR = 1'b0 ;

  // submodule cpReqF
  assign cpReqF$D_IN =
	     { !tlpReq[62],
	       IF_tlpReq_3_BIT_62_4_THEN_tlpDWAddr_8_BITS_21__ETC___d113 } ;
  assign cpReqF$ENQ =
	     cpReqF_i_notFull__2_AND_NOT_tlpReq_3_BIT_62_4__ETC___d82 &&
	     tlpActive ;
  assign cpReqF$DEQ = EN_client_request_get ;
  assign cpReqF$CLR = 1'b0 ;

  // submodule cpRespF
  assign cpRespF$D_IN = client_response_put ;
  assign cpRespF$ENQ = EN_client_response_put ;
  assign cpRespF$DEQ =
	     WILL_FIRE_RL_tlpFirstComplWord || WILL_FIRE_RL_tlpStageNextWord ;
  assign cpRespF$CLR = 1'b0 ;

  // submodule inF
  assign inF$D_IN = server_request_put ;
  assign inF$ENQ = EN_server_request_put ;
  assign inF$DEQ =
	     WILL_FIRE_RL_tlpReqGen && tlpReq[62] && !tlpFirst ||
	     WILL_FIRE_RL_tlpFirstRcv ;
  assign inF$CLR = 1'b0 ;

  // submodule outF
  assign outF$D_IN =
	     WILL_FIRE_RL_tlpFirstComplWord ?
	       MUX_outF$enq_1__VAL_1 :
	       MUX_outF$enq_1__VAL_2 ;
  assign outF$ENQ =
	     WILL_FIRE_RL_tlpFirstComplWord || WILL_FIRE_RL_tlpNextComplWord ;
  assign outF$DEQ = EN_server_response_get ;
  assign outF$CLR = 1'b0 ;

  // remaining internal signals
  assign IF_tlpReq_3_BIT_62_4_AND_NOT_tlpFirst_6_4_5_TH_ETC___d102 =
	     (tlpReq[62] && !tlpFirst) ? v__h2549 : tlpDW ;
`ifdef olf
  assign IF_tlpReq_3_BIT_62_4_THEN_tlpDWAddr_8_BITS_21__ETC___d113 =
	     tlpReq[62] ?
	       { tlpDWAddr[21:0],
		 _theResult_____2__h2491,
		 wreq_data__h3050 } :
	       { 24'hAAAAAA,
		 tlpReq[15:8],
		 tlpDWAddr[21:0],
		 _theResult_____2__h2491 } ;
`else
  assign IF_tlpReq_3_BIT_62_4_THEN_tlpDWAddr_8_BITS_21__ETC___d113 =
             { tlpDWAddr[23:0],         // DW addr 24 bits, 64MB, 63 workers
	       _theResult_____2__h2491, // byte enable
	       tlpReq[62] ? wreq_data__h3050 : { 24'h000000, tlpReq[15:8]}
	       };
`endif
  assign _theResult_____2__h2491 =
	     tlpFirst ?
	       tlpReq[3:0] :
	       ((tlpUnroll == 10'd1) ? tlpReq[7:4] : 4'hF) ;
  assign byteCount__h2076 = x__h2295 - y__h2296 ;
  assign cpReqF_i_notFull__2_AND_NOT_tlpReq_3_BIT_62_4__ETC___d82 =
	     cpReqF$FULL_N && (!tlpReq[62] || tlpFirst || inF$EMPTY_N) ;
  assign lowAddr__h2075 = { inF$D_OUT[38:34], lowAddr10__h2074 } ;
  assign pkt__h4230 =
	     { 9'd148,
	       cmpF$D_OUT[39:37],
	       10'd0,
	       cmpF$D_OUT[21:12],
	       pciDevice,
	       4'd0,
	       cmpF$D_OUT[11:0],
	       cmpF$D_OUT[55:40],
	       cmpF$D_OUT[36:29],
	       1'b0,
	       cmpF$D_OUT[28:22],
	       cpRespF$D_OUT[7:0],
	       cpRespF$D_OUT[15:8],
	       cpRespF$D_OUT[23:16],
	       cpRespF$D_OUT[31:24] } ;
  assign pw_be__h7277 = (rss == 2'd2) ? lastRema__h7245 : 16'd65535 ;
  assign pw_data__h7278 =
	     x__h7701[1] ?
	       (x__h7701[0] ?
		  { rdv[31:0], rdv[127:32] } :
		  { rdv[63:0], rdv[127:64] }) :
	       (x__h7701[0] ? { rdv[95:0], rdv[127:96] } : rdv) ;
  assign wreq_data__h3050 =
	     { IF_tlpReq_3_BIT_62_4_AND_NOT_tlpFirst_6_4_5_TH_ETC___d102[7:0],
	       IF_tlpReq_3_BIT_62_4_AND_NOT_tlpFirst_6_4_5_TH_ETC___d102[15:8],
	       IF_tlpReq_3_BIT_62_4_AND_NOT_tlpFirst_6_4_5_TH_ETC___d102[23:16],
	       IF_tlpReq_3_BIT_62_4_AND_NOT_tlpFirst_6_4_5_TH_ETC___d102[31:24] } ;
  assign x__h2295 = x__h2297 - y__h2298 ;
  assign x__h2297 = { inF$D_OUT[105:96], 2'b0 } ;
  assign x__h7701 = 3'h4 - { 1'd0, rdp } ;
  assign y__h2296 =
	     (inF$D_OUT[105:96] == 10'd1) ? 12'd0 : { 10'd0, x__h2327 } ;
  assign y__h2298 = { 10'd0, x__h2304 } ;
  always@(inF$D_OUT)
  begin
    case (inF$D_OUT[67:64])
      4'b1100: x__h2304 = 2'b10;
      4'b1110: x__h2304 = 2'b01;
      4'b1111: x__h2304 = 2'b0;
      default: x__h2304 = 2'b11;
    endcase
  end
  always@(inF$D_OUT)
  begin
    case (inF$D_OUT[71:68])
      4'b1100: x__h2327 = 2'b10;
      4'b1110: x__h2327 = 2'b01;
      4'b1111: x__h2327 = 2'b0;
      default: x__h2327 = 2'b11;
    endcase
  end
  always@(tlpDWp or inF$D_OUT)
  begin
    case (tlpDWp)
      2'd0: v__h2549 = inF$D_OUT[31:0];
      2'd1: v__h2549 = inF$D_OUT[63:32];
      2'd2: v__h2549 = inF$D_OUT[95:64];
      2'd3: v__h2549 = inF$D_OUT[127:96];
    endcase
  end
  always@(rdp)
  begin
    case (rdp)
      2'b0: lastRema__h7245 = 16'hFFFF;
      2'b01: lastRema__h7245 = 16'hF000;
      2'b10: lastRema__h7245 = 16'hFF00;
      2'd3: lastRema__h7245 = 16'hFFF0;
    endcase
  end
  always@(inF$D_OUT)
  begin
    case (inF$D_OUT[67:64])
      4'b1000: lowAddr10__h2074 = 2'b11;
      4'b1100: lowAddr10__h2074 = 2'b10;
      4'b1110: lowAddr10__h2074 = 2'b01;
      default: lowAddr10__h2074 = 2'b0;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        cmpActive <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rdp <= `BSV_ASSIGNMENT_DELAY 2'd0;
	rss <= `BSV_ASSIGNMENT_DELAY 2'd0;
	tlpActive <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (cmpActive$EN) cmpActive <= `BSV_ASSIGNMENT_DELAY cmpActive$D_IN;
	if (rdp$EN) rdp <= `BSV_ASSIGNMENT_DELAY rdp$D_IN;
	if (rss$EN) rss <= `BSV_ASSIGNMENT_DELAY rss$D_IN;
	if (tlpActive$EN) tlpActive <= `BSV_ASSIGNMENT_DELAY tlpActive$D_IN;
      end
    if (cmpDWRemain$EN) cmpDWRemain <= `BSV_ASSIGNMENT_DELAY cmpDWRemain$D_IN;
    if (rdv$EN) rdv <= `BSV_ASSIGNMENT_DELAY rdv$D_IN;
    if (tlpDW$EN) tlpDW <= `BSV_ASSIGNMENT_DELAY tlpDW$D_IN;
    if (tlpDWAddr$EN) tlpDWAddr <= `BSV_ASSIGNMENT_DELAY tlpDWAddr$D_IN;
    if (tlpDWp$EN) tlpDWp <= `BSV_ASSIGNMENT_DELAY tlpDWp$D_IN;
    if (tlpFirst$EN) tlpFirst <= `BSV_ASSIGNMENT_DELAY tlpFirst$D_IN;
    if (tlpReq$EN) tlpReq <= `BSV_ASSIGNMENT_DELAY tlpReq$D_IN;
    if (tlpUnroll$EN) tlpUnroll <= `BSV_ASSIGNMENT_DELAY tlpUnroll$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    cmpActive = 1'h0;
    cmpDWRemain = 10'h2AA;
    rdp = 2'h2;
    rdv = 128'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    rss = 2'h2;
    tlpActive = 1'h0;
    tlpDW = 32'hAAAAAAAA;
    tlpDWAddr = 30'h2AAAAAAA;
    tlpDWp = 2'h2;
    tlpFirst = 1'h0;
    tlpReq = 64'hAAAAAAAAAAAAAAAA;
    tlpUnroll = 10'h2AA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkTLPSerializer

