/*
 * This file is protected by Copyright. Please refer to the COPYRIGHT file
 * distributed with this source distribution.
 *
 * This file is part of OpenCPI <http://www.opencpi.org>
 *
 * OpenCPI is free software: you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * OpenCPI is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

//
// Generated by Bluespec Compiler, version 2012.09.beta1 (build 29570, 2012-09.11)
//
// On Wed Oct 24 10:26:13 EDT 2012
//
//
// Ports:
// Name                         I/O  size props
// RDY_s_request_put              O     1
// s_response_get                 O   153
// RDY_s_response_get             O     1
// c0_request_get                 O   153
// RDY_c0_request_get             O     1
// RDY_c0_response_put            O     1
// c1_request_get                 O   153
// RDY_c1_request_get             O     1
// RDY_c1_response_put            O     1
// pfk                            I    14
// CLK                            I     1 clock
// RST_N                          I     1 reset
// s_request_put                  I   153
// c0_response_put                I   153
// c1_response_put                I   153
// EN_s_request_put               I     1
// EN_c0_response_put             I     1
// EN_c1_response_put             I     1
// EN_s_response_get              I     1
// EN_c0_request_get              I     1
// EN_c1_request_get              I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkTLPSM(pfk,
	       CLK,
	       RST_N,

	       s_request_put,
	       EN_s_request_put,
	       RDY_s_request_put,

	       EN_s_response_get,
	       s_response_get,
	       RDY_s_response_get,

	       EN_c0_request_get,
	       c0_request_get,
	       RDY_c0_request_get,

	       c0_response_put,
	       EN_c0_response_put,
	       RDY_c0_response_put,

	       EN_c1_request_get,
	       c1_request_get,
	       RDY_c1_request_get,

	       c1_response_put,
	       EN_c1_response_put,
	       RDY_c1_response_put);
  input  [13 : 0] pfk;
  input  CLK;
  input  RST_N;

  // action method s_request_put
  input  [152 : 0] s_request_put;
  input  EN_s_request_put;
  output RDY_s_request_put;

  // actionvalue method s_response_get
  input  EN_s_response_get;
  output [152 : 0] s_response_get;
  output RDY_s_response_get;

  // actionvalue method c0_request_get
  input  EN_c0_request_get;
  output [152 : 0] c0_request_get;
  output RDY_c0_request_get;

  // action method c0_response_put
  input  [152 : 0] c0_response_put;
  input  EN_c0_response_put;
  output RDY_c0_response_put;

  // actionvalue method c1_request_get
  input  EN_c1_request_get;
  output [152 : 0] c1_request_get;
  output RDY_c1_request_get;

  // action method c1_response_put
  input  [152 : 0] c1_response_put;
  input  EN_c1_response_put;
  output RDY_c1_response_put;

  // signals for module outputs
  wire [152 : 0] c0_request_get, c1_request_get, s_response_get;
  wire RDY_c0_request_get,
       RDY_c0_response_put,
       RDY_c1_request_get,
       RDY_c1_response_put,
       RDY_s_request_put,
       RDY_s_response_get;

  // ports of submodule pktFork
  wire [152 : 0] pktFork$iport_put, pktFork$oport0_get, pktFork$oport1_get;
  wire pktFork$EN_iport_put,
       pktFork$EN_oport0_get,
       pktFork$EN_oport1_get,
       pktFork$RDY_iport_put,
       pktFork$RDY_oport0_get,
       pktFork$RDY_oport1_get;

  // ports of submodule pktMerge
  wire [152 : 0] pktMerge$iport0_put, pktMerge$iport1_put, pktMerge$oport_get;
  wire pktMerge$EN_iport0_put,
       pktMerge$EN_iport1_put,
       pktMerge$EN_oport_get,
       pktMerge$RDY_iport0_put,
       pktMerge$RDY_iport1_put,
       pktMerge$RDY_oport_get;

  // remaining internal signals
  reg [1 : 0] CASE_pfk_BITS_13_TO_12_3_0_pfk_BITS_13_TO_12_1_ETC__q1;
  wire [13 : 0] x__h110;

  // action method s_request_put
  assign RDY_s_request_put = pktFork$RDY_iport_put ;

  // actionvalue method s_response_get
  assign s_response_get = pktMerge$oport_get ;
  assign RDY_s_response_get = pktMerge$RDY_oport_get ;

  // actionvalue method c0_request_get
  assign c0_request_get = pktFork$oport0_get ;
  assign RDY_c0_request_get = pktFork$RDY_oport0_get ;

  // action method c0_response_put
  assign RDY_c0_response_put = pktMerge$RDY_iport0_put ;

  // actionvalue method c1_request_get
  assign c1_request_get = pktFork$oport1_get ;
  assign RDY_c1_request_get = pktFork$RDY_oport1_get ;

  // action method c1_response_put
  assign RDY_c1_response_put = pktMerge$RDY_iport1_put ;

  // submodule pktFork
  mkPktFork pktFork(.pfk(x__h110),
		    .CLK(CLK),
		    .RST_N(RST_N),
		    .iport_put(pktFork$iport_put),
		    .EN_iport_put(pktFork$EN_iport_put),
		    .EN_oport0_get(pktFork$EN_oport0_get),
		    .EN_oport1_get(pktFork$EN_oport1_get),
		    .RDY_iport_put(pktFork$RDY_iport_put),
		    .oport0_get(pktFork$oport0_get),
		    .RDY_oport0_get(pktFork$RDY_oport0_get),
		    .oport1_get(pktFork$oport1_get),
		    .RDY_oport1_get(pktFork$RDY_oport1_get));

  // submodule pktMerge
  mkPktMerge pktMerge(.CLK(CLK),
		      .RST_N(RST_N),
		      .iport0_put(pktMerge$iport0_put),
		      .iport1_put(pktMerge$iport1_put),
		      .EN_iport0_put(pktMerge$EN_iport0_put),
		      .EN_iport1_put(pktMerge$EN_iport1_put),
		      .EN_oport_get(pktMerge$EN_oport_get),
		      .RDY_iport0_put(pktMerge$RDY_iport0_put),
		      .RDY_iport1_put(pktMerge$RDY_iport1_put),
		      .oport_get(pktMerge$oport_get),
		      .RDY_oport_get(pktMerge$RDY_oport_get));

  // submodule pktFork
  assign pktFork$iport_put = s_request_put ;
  assign pktFork$EN_iport_put = EN_s_request_put ;
  assign pktFork$EN_oport0_get = EN_c0_request_get ;
  assign pktFork$EN_oport1_get = EN_c1_request_get ;

  // submodule pktMerge
  assign pktMerge$iport0_put = c0_response_put ;
  assign pktMerge$iport1_put = c1_response_put ;
  assign pktMerge$EN_iport0_put = EN_c0_response_put ;
  assign pktMerge$EN_iport1_put = EN_c1_response_put ;
  assign pktMerge$EN_oport_get = EN_s_response_get ;

  // remaining internal signals
  assign x__h110 =
	     { CASE_pfk_BITS_13_TO_12_3_0_pfk_BITS_13_TO_12_1_ETC__q1,
	       pfk[11:0] } ;
  always@(pfk)
  begin
    case (pfk[13:12])
      2'd0, 2'd1, 2'd2:
	  CASE_pfk_BITS_13_TO_12_3_0_pfk_BITS_13_TO_12_1_ETC__q1 = pfk[13:12];
      2'd3: CASE_pfk_BITS_13_TO_12_3_0_pfk_BITS_13_TO_12_1_ETC__q1 = 2'd3;
    endcase
  end
endmodule  // mkTLPSM

